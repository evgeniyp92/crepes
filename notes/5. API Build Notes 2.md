# Build notes part 2

## Handling stray api requests

If you have a request that makes it past all your routes you should then have a catch-all route to respond with a 404

Instead of declaring a bunch of `app.verbs` you can just use `app.all()`

```javascript
app.all('*', (request, response, next) => {
    response.status(404).json({
        status: 'fail',
        message: `Route ${request.originalUrl} does not exist`,
    });
});
```

## Express error handling

Important to distinguish btwn two types of errors

-   Operational
-   Programming

Operational errors are ones that we can predict and control for, usually this boils to everything that is not PEBKAC

Programming errors are basically PEBKAC type stuff

Also, exceptions and errors are interchangeable

Express actually comes with error handling out of the box, so we can just write a global middleware to handle our error signaling that can accept error signals from anywhere in the app

Global error handling middleware enables us to maintain good separation of concerns btwn business logic and applicatin logic

Here is an example of a better error handling mechanism than the one above (in app.js)

```javascript
// Controlling for a route that isnt handled by any router listed above
app.all('*', (request, response, next) => {
    // response.status(404).json({
    //   status: 'fail',
    //   message: `Route ${request.originalUrl} does not exist`,
    // });

    const error = new Error(
        `Requested route ${request.originalUrl} does not exist`
    );
    error.status = 'fail';
    error.statusCode = 404;

    // passing an error to next() will cause it to go to our error handler
    next(error);
});

app.use((error, request, response, next) => {
    // eslint-disable-next-line no-param-reassign
    error.statusCode = error.statusCode || 500;
    // eslint-disable-next-line no-param-reassign
    error.status = error.status || 'Unknown error';

    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
    });
});
```

# Making a custom Error class

```javascript
class AppError extends Error {
    constructor(message, statusCode) {
        // calling the parent class which already has a message
        super(message);

        this.statusCode = statusCode;
        // of the status code starts with a 4 its a fail otherwise its error
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        // setting this to be just for operational errors
        this.isOperational = true;

        // adding a stack trace
        Error.captureStackTrace(this, this.constructor);
    }
}

module.exports = AppError;
```

```javascript
// Controlling for a route that isnt handled by any router listed above
app.all('*', (request, response, next) => {
    next(
        new AppError(
            `Requested route ${request.originalUrl} does not exist`,
            404
        )
    );
});
```

making a custom controller for errors

```javascript
/* eslint-disable no-param-reassign */
module.exports = (error, request, response, next) => {
    error.statusCode = error.statusCode || 500;
    error.status = error.status || 'Unknown error';

    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
    });
};
```

import the new controller up top then use it like so

```javascript
// Controlling for a route that isnt handled by any router listed above
app.all('*', (request, response, next) => {
    // const error = new Error(
    //   `Requested route ${request.originalUrl} does not exist`
    // );
    // error.status = 'fail';
    // error.statusCode = 404;

    // passing an error to next() will cause it to go to our error handler
    next(
        new AppError(
            `Requested route ${request.originalUrl} does not exist`,
            404
        )
    );
});

app.use(globalErrorHandler);
```

## Wordy explanation of the refactor

At the bottom of our app.js we create an `app.all()` to handle any route requests that dont get handled by any of our actual routers (effectively, a default).

```javascript
app.all('*', (request, response, next) => {
    next(
        new AppError(
            `Requested route ${request.originalUrl} does not exist`,
            404
        )
    );
});
```

In that, we assume that since no router higher up was hit, the request is invalid. In the callback function we simply call next() and generate a new AppError. AppError is a custom class that we have created to handle errors easier for us as well as to enable us to capture stack traces on our exceptions.

```javascript
class AppError extends Error {
    constructor(message, statusCode) {
        // calling the parent class which already has a message
        super(message);

        this.statusCode = statusCode;
        // of the status code starts with a 4 its a fail otherwise its error
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        // setting this to be just for operational errors
        this.isOperational = true;

        // adding a stack trace
        Error.captureStackTrace(this, this.constructor);
    }
}

module.exports = AppError;
```

With this class we can create a custom controller to quickly spawn errors

```javascript
/* eslint-disable no-param-reassign */
module.exports = (error, request, response, next) => {
    error.statusCode = error.statusCode || 500;
    error.status = error.status || 'Unknown error';

    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
    });
};
```

We then use this controller as the route handler at the bottom of our `app.js`

```javascript
app.use(errorController);
```

## Removing try catch blocks from controllers

Simply wrap async function inside another function, which must return an anonymous function so that it can be reassigned to your original route export, otherwise the catch function executes on compile and cant access `request`, `response` or `next`

Before:

```javascript
exports.createTour = async (request, response) => {
    try {
        // Creating an instance of a Tour and then calling its methods
        // const newTour = new Tour({});
        // newTour.save();

        // Rawdogging it and calling the method off the parent
        const newTour = await Tour.create(request.body);

        response.status(201).json({
            status: 'success',
            data: {
                tour: newTour,
            },
        });
    } catch (error) {
        response.status(400).json({
            status: 'fail',
            message: 'Invalid data sent',
            details: error,
        });
    }
};
```

After:

```javascript
const catchAsync = fn => (request, response, next) => {
    fn(request, response, next).catch(error => next(error));
};

exports.createTour = catchAsync(async (request, response, next) => {
    const newTour = await Tour.create(request.body);

    response.status(201).json({
        status: 'success',
        data: {
            tour: newTour,
        },
    });
});
```
