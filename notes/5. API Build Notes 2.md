# Build notes part 2

## Handling stray api requests

If you have a request that makes it past all your routes you should then have a catch-all route to respond with a 404

Instead of declaring a bunch of `app.verbs` you can just use `app.all()`

```javascript
app.all('*', (request, response, next) => {
    response.status(404).json({
        status: 'fail',
        message: `Route ${request.originalUrl} does not exist`,
    });
});
```

## Express error handling

Important to distinguish btwn two types of errors

-   Operational
-   Programming

Operational errors are ones that we can predict and control for, usually this boils to everything that is not PEBKAC

Programming errors are basically PEBKAC type stuff

Also, exceptions and errors are interchangeable

Express actually comes with error handling out of the box, so we can just write a global middleware to handle our error signaling that can accept error signals from anywhere in the app

Global error handling middleware enables us to maintain good separation of concerns btwn business logic and applicatin logic

Here is an example of a better error handling mechanism than the one above (in app.js)

```javascript
// Controlling for a route that isnt handled by any router listed above
app.all('*', (request, response, next) => {
    // response.status(404).json({
    //   status: 'fail',
    //   message: `Route ${request.originalUrl} does not exist`,
    // });

    const error = new Error(
        `Requested route ${request.originalUrl} does not exist`
    );
    error.status = 'fail';
    error.statusCode = 404;

    // passing an error to next() will cause it to go to our error handler
    next(error);
});

app.use((error, request, response, next) => {
    // eslint-disable-next-line no-param-reassign
    error.statusCode = error.statusCode || 500;
    // eslint-disable-next-line no-param-reassign
    error.status = error.status || 'Unknown error';

    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
    });
});
```

# Making a custom Error class

```javascript
class AppError extends Error {
    constructor(message, statusCode) {
        // calling the parent class which already has a message
        super(message);

        this.statusCode = statusCode;
        // of the status code starts with a 4 its a fail otherwise its error
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        // setting this to be just for operational errors
        this.isOperational = true;

        // adding a stack trace
        Error.captureStackTrace(this, this.constructor);
    }
}

module.exports = AppError;
```

```javascript
// Controlling for a route that isnt handled by any router listed above
app.all('*', (request, response, next) => {
    next(
        new AppError(
            `Requested route ${request.originalUrl} does not exist`,
            404
        )
    );
});
```

making a custom controller for errors

```javascript
/* eslint-disable no-param-reassign */
module.exports = (error, request, response, next) => {
    error.statusCode = error.statusCode || 500;
    error.status = error.status || 'Unknown error';

    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
    });
};
```

import the new controller up top then use it like so

```javascript
// Controlling for a route that isnt handled by any router listed above
app.all('*', (request, response, next) => {
    // const error = new Error(
    //   `Requested route ${request.originalUrl} does not exist`
    // );
    // error.status = 'fail';
    // error.statusCode = 404;

    // passing an error to next() will cause it to go to our error handler
    next(
        new AppError(
            `Requested route ${request.originalUrl} does not exist`,
            404
        )
    );
});

app.use(globalErrorHandler);
```

## Wordy explanation of the refactor

At the bottom of our app.js we create an `app.all()` to handle any route requests that dont get handled by any of our actual routers (effectively, a default).

```javascript
app.all('*', (request, response, next) => {
    next(
        new AppError(
            `Requested route ${request.originalUrl} does not exist`,
            404
        )
    );
});
```

In that, we assume that since no router higher up was hit, the request is invalid. In the callback function we simply call next() and generate a new AppError. AppError is a custom class that we have created to handle errors easier for us as well as to enable us to capture stack traces on our exceptions.

```javascript
class AppError extends Error {
    constructor(message, statusCode) {
        // calling the parent class which already has a message
        super(message);

        this.statusCode = statusCode;
        // of the status code starts with a 4 its a fail otherwise its error
        this.status = `${statusCode}`.startsWith('4') ? 'fail' : 'error';
        // setting this to be just for operational errors
        this.isOperational = true;

        // adding a stack trace
        Error.captureStackTrace(this, this.constructor);
    }
}

module.exports = AppError;
```

With this class we can create a custom controller to quickly spawn errors

```javascript
/* eslint-disable no-param-reassign */
module.exports = (error, request, response, next) => {
    error.statusCode = error.statusCode || 500;
    error.status = error.status || 'Unknown error';

    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
    });
};
```

We then use this controller as the route handler at the bottom of our `app.js`

```javascript
app.use(errorController);
```

## Removing try catch blocks from controllers

Simply wrap async function inside another function, which must return an anonymous function so that it can be reassigned to your original route export, otherwise the catch function executes on compile and cant access `request`, `response` or `next`

Before:

```javascript
exports.createTour = async (request, response) => {
    try {
        // Creating an instance of a Tour and then calling its methods
        // const newTour = new Tour({});
        // newTour.save();

        // Rawdogging it and calling the method off the parent
        const newTour = await Tour.create(request.body);

        response.status(201).json({
            status: 'success',
            data: {
                tour: newTour,
            },
        });
    } catch (error) {
        response.status(400).json({
            status: 'fail',
            message: 'Invalid data sent',
            details: error,
        });
    }
};
```

After:

```javascript
const catchAsync = fn => (request, response, next) => {
    fn(request, response, next).catch(error => next(error));
};

exports.createTour = catchAsync(async (request, response, next) => {
    const newTour = await Tour.create(request.body);

    response.status(201).json({
        status: 'success',
        data: {
            tour: newTour,
        },
    });
});
```

You can also use the catchAsync helper in the router file too, but it makes it harder to track whats async and what isnt

Example of throwing an error in a handler function with this new method

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
    const tour = await Tour.findById(request.params.id);

    if (!tour) {
        return next(new AppError('Requested tour does not exist', 404));
    }

    response.json({
        status: 'success',
        params: request.params,
        data: {
            tour,
        },
    });
});
```

Separating operational/trusted errors from errors not caused by us

```javascript
const sendErrorForUser = (error, response) => {
    if (error.isOperational) {
        response.status(error.statusCode).json({
            status: error.status,
            message: error.message,
        });
    } else {
        response.status(500).json({
            status: 'error',
            message: `Unknown error`,
        });
    }
};
```

Important to note that you also need to make errors from trusted platforms operational everywhere, so that mongoose errors dont throw a generic error for instance

```javascript
const handleCastErrorDB = error => {
    const message = `Invalid: ${error.path} is ${error.value}`;
    return new AppError(message, 400);
};

const handleDuplicateFieldsDB = error => {
    const duplicateFields = Object.keys(error.keyPattern).join(', ');
    const message = `Duplicate field values for the following: ${duplicateFields}. please use another value`;
    return new AppError(message, 400);
};

const handleValidationErrorDB = error => {
    const invalidFields = Object.values(error.errors).map(
        element => element.message
    );
    const message = `Invalid input data. ${invalidFields.join('. ')}.`;
    return new AppError(message, 400);
};
```

Entire error controller

```javascript
const AppError = require('../utils/appError');

/* eslint-disable no-param-reassign */
// Error generators
const handleCastErrorDB = error => {
    const message = `Invalid: ${error.path} is ${error.value}`;
    return new AppError(message, 400);
};

const handleDuplicateFieldsDB = error => {
    const duplicateFields = Object.keys(error.keyPattern).join(', ');
    const message = `Duplicate field values for the following: ${duplicateFields}. please use another value`;
    return new AppError(message, 400);
};

const handleValidationErrorDB = error => {
    const invalidFields = Object.values(error.errors).map(
        element => element.message
    );
    const message = `Invalid input data. ${invalidFields.join('. ')}.`;
    return new AppError(message, 400);
};

// Error handlers
const sendErrorForDev = (error, response) => {
    response.status(error.statusCode).json({
        status: error.status,
        message: error.message,
        stack: error.stack,
        error: { ...error, name: error.name },
    });
};

const sendErrorForProd = (error, response) => {
    if (error.isOperational) {
        response.status(error.statusCode).json({
            status: error.status,
            message: error.message,
        });
    } else {
        // eslint-disable-next-line no-console
        console.log(`ðŸ¤– ERROR ðŸ¤–: ${error}`);
        response.status(500).json({
            status: 'error',
            message: `Unknown error, probably caused by a dependancy.`,
        });
    }
};

// Core function
module.exports = (error, request, response, next) => {
    error.statusCode = error.statusCode || 500;
    error.status =
        error.status ||
        'Unhandled error ðŸ˜¬, you should not be able to see this if you are in prod';

    if (process.env.NODE_ENV === 'development') {
        // sending error in development
        sendErrorForDev(error, response);
    } else if (process.env.NODE_ENV === 'production') {
        // sending errors in production

        // for some goddamn reason you have to spread error, and then create a name
        // property with a value of error.name, otherwise the property isnt readable
        let err = { ...error, name: error.name };
        if (err.name === 'CastError') err = handleCastErrorDB(err);
        if (err.code === 11000) err = handleDuplicateFieldsDB(err);
        if (err.name === 'ValidationError') err = handleValidationErrorDB(err);

        sendErrorForProd(err, response);
    }
};
```

# Handling unhandled promise rejections

```javascript
// handling promise rejections
process.on('unhandledRejection', error => {
    console.log(error.name, error.message);
});
```

or a bit more complex

```javascript
const server = app.listen(port, () => {
    // eslint-disable-next-line no-console
    console.log(`App running on port ${port}...`);
});

// handling promise rejections
process.on('unhandledRejection', error => {
    console.warn(error.name, error.message);
    console.error(`UNHANDLED REJECTION, SHUTTING DOWN...`);
    server.close(() => {
        process.exit(1);
    });
});
```

errors spawned in middleware will get passed off to express error handling middleware
