# Natours build notes

## Express

Express is a minimal node framework thats built on node using node code

Has a very robust set of features

- complex routing
- easier handling of requests and responses
- middleware
- ssr

this saves us the trouble of having to reinvent the wheel when we config an api

express also makes it easier to organize our app into an mvc architecture

it is convention to configure all of express in app.js

Initializing express

```javascript
const express = require('express');

const app = express();

const PORT = 4000;

app.listen(PORT, () => {
  console.log(`App running on port ${PORT}...`);
});
```

basic route

```javascript
app.get('/', (request, response) => {
  response.status(200).send('Hello from the server side!');
});
```

sending json instead of plain text

```javascript
app.get('/', (request, response) => {
  response.status(200).json({
    message: `Hello from the server side!`,
    app: 'Natours',
  });
});
```

the http 200 response is default so you dont have to explicitly set it

also the json method automatically sets the header to app/json

## APIs and RESTful API design

An API is a piece of software that is used by another piece of software to allow apps to talk to each other

So it's a facilitator application

This can mean a Web API, or something smaller like `fs` or `http`, the DOM JS API, publicly exposed methods in oop, etc etc

### REST stands for REpresentational State Transfer

It's a logical way of building API's making them easy to consume

- Separate API into logical resources
  - Key abstraction of info in REST
  - A resource is an object or representation of something with some data associated to it
  - i.e. tours, users, reviews (all nouns)
- Exposed them via structured, resource-based URLS,
  - endpoints should only contain resources and not the actions to be performed on them
  - i.e. instead of `/getTour` use `/tours` with a `GET` method
  - common verbs are GET, POST, DELETE, PATCH (only supply whats been changed), PUT (send the entire object)
- Use the right HTTP methods (verbs)
  - Follow the CRUDL operations if possible
- Send data as JSON where possible
  - Nice for both computers and humans to understand
  - Expandable with things like JSend (envelops data to imporove security and make response status explicit)
- Be stateless
  - All state is handled on the client and not on the server
  - Like loggedIn or currentPage
  - So all information to process the request must be included in it
  - The server shouldnt keep anything in memory
  - i.e. instead of making the server track what the currentpage is, request pages explicitly

The request data holds what was sent but Express cant access it by default so we need middleware -- add `app.use(express.json())` to get express to receive the body

## The request-response cycle

- Our app receives a request
- It generates a request and a response object
- We use middleware to process the request (like `express.json` (aka bodyparser))
- The order of middlewares in the stack is defined by their order in the code

```javascript
// adding an additional function to the middleware stack
app.use((req, res, next) => {
  // we get access to the request, response, and the next function
  console.log('Hello from our custom middleware ðŸ’©');
  // without calling the next function the flow would hang
  next();
});
```

When middleware is declared globally it will run everywhere but it is possible to have middleware run for only specific route handlers, depending when the middleware is declared

```javascript
// faster way of declaring routes than above
// declare the endpoint and then chain all applicable methods
app.route('/api/v1/tours').get(getAllTours).post(createTour);
app.use((req, res, next) => {
  // we get access to the request, response, and the next function
  console.log('Hello from our custom middleware ðŸ’©');
  // without calling the next function the flow would hang
  next();
});
app
  .route('/api/v1/tours/:id')
  .get(getTour)
  .patch(updateTour)
  .delete(deleteTour);
```

route handlers typically are at the end of the request response cycle so the custom middleware is not used

adding additional data to the request object to be consumed at a later point

```javascript
// manipulating the request object
app.use((req, res, next) => {
  // appending the time of the request to the request
  // @ts-ignore
  req.currentTime = new Date().toISOString();
  next();
});

const getAllTours = (request, response) => {
  console.log(request.currentTime);
  response.json({
    status: 'success',
    requestedAt: request.currentTime,
    results: tours.length,
    data: {
      tours,
    },
  });
};
```

refactoring our routes to use dedicated routers

```javascript
// before
app.route('/api/v1/tours').get(getAllTours).post(createTour);

app
  .route('/api/v1/tours/:id')
  .get(getTour)
  .patch(updateTour)
  .delete(deleteTour);

// after
const tourRouter = express.Router();
app.use('/api/v1/tours', tourRouter);
tourRouter.route('/').get(getAllTours).post(createTour);
tourRouter.route('/:id').get(getTour).patch(updateTour).delete(deleteTour);
```

this kind of refactoring is called router mounting

end result:

```javascript
const tourRouter = express.Router();
const userRouter = express.Router();

tourRouter.route('/').get(getAllTours).post(createTour);
tourRouter.route('/:id').get(getTour).patch(updateTour).delete(deleteTour);
userRouter.route('/').get(getAllUsers).post(createUser);
userRouter.route('/:id').get(getUser).patch(updateUser).delete(deleteUser);

app.use('/api/v1/tours', tourRouter);
app.use('/api/v1/users', userRouter);
```

## MVC-ifying our app

MVC will be covered at a later date but what this does is break out all our logic into separate files

### New app.js

```javascript
const express = require('express');
const morgan = require('morgan');

// Importing routers
const tourRouter = require('./routes/tourRoutes');
const userRouter = require('./routes/userRoutes');

// Initializing application
const app = express();

// MIDDLEWARES -- DECLARE ALL YOUR MIDDLEWARE HERE FOR GLOBAL MIDDLEWARE
app.use(express.json());
app.use(morgan('dev'));
app.use((req, res, next) => {
  console.log('Hello from our custom middleware ðŸ’©');
  next();
});
app.use((req, res, next) => {
  // appending the time of the request to the request
  // @ts-ignore
  req.currentTime = new Date().toISOString();
  next();
});

// Mounting routers -- YES THIS IS ALSO MIDDLEWARE
app.use('/api/v1/tours', tourRouter);
app.use('/api/v1/users', userRouter);

// SERVER
const PORT = 4000;
app.listen(PORT, () => {
  console.log(`App running on port ${PORT}...`);
});
```

### routes/tourRoutes.js

```javascript
const express = require('express');
const tourController = require('../controllers/tourController');
const router = express.Router();

router
  .route('/')
  .get(tourController.getAllTours)
  .post(tourController.createTour);
router
  .route('/:id')
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(tourController.deleteTour);

module.exports = router;
```

### routes/userRoutes.js

```javascript
const express = require('express');
const userController = require('../controllers/userController');

const router = express.Router();

router
  .route('/')
  .get(userController.getAllUsers)
  .post(userController.createUser);
router
  .route('/:id')
  .get(userController.getUser)
  .patch(userController.updateUser)
  .delete(userController.deleteUser);

module.exports = router;
```

### controllers/tourController.js

```javascript
const fs = require('fs');

// all the router logic at this point has been extracted to its own file
const tours = JSON.parse(
  // @ts-ignore
  fs.readFileSync(`${__dirname}/../dev-data/data/tours-simple.json`)
);

exports.getAllTours = (request, response) => {
  console.log(request.currentTime);
  response.json({
    status: 'success',
    requestedAt: request.currentTime,
    results: tours.length,
    data: {
      tours,
    },
  });
};
exports.getTour = (request, response) => {
  const { params } = request;
  const tour = tours.find(element => element.id === Number(params.id));
  // controlling for insane request
  // general catch for if an id doesnt come back
  if (!tour) {
    return response.status(404).json({
      status: 'fail',
      reason: 'Invalid ID',
    });
  }
  // deterministically checking for an out of range id
  if (Number(params.id) > tours.length) {
    return response.status(404).json({
      status: 'fail',
      reason: 'id is not valid, probably too high!',
    });
  }
  // actually processing and responding if the checks pass
  response.json({
    status: 'success',
    params,
    data: {
      tour,
    },
  });
};
exports.createTour = (request, response) => {
  // first thing is to figure out the id of the object, since the db wont do it for us here
  // figuring out the id based on the length of the tours array
  const newId = tours[tours.length - 1].id + 1;
  // merging together an adhoc object and the request.body
  const newTour = Object.assign({ id: newId }, request.body);
  // pushing new item into tours array
  tours.push(newTour);
  // writing the new array to file
  fs.writeFile(
    `${__dirname}/dev-data/data/tours-simple.json`,
    // supplying a stringified version of the object as data
    JSON.stringify(tours),
    // once the write is complete, we send a response indicating it is done
    error => {
      response.status(201).json({
        status: 'success',
        data: {
          tour: newTour,
        },
      });
    }
  );
};
exports.updateTour = ({ params, body }, response) => {
  // checking that the things we need exist
  if (!params || !body) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide params and a body!',
    });
  }
  // checking that the id is in range
  if (Number(params.id) > tours.length) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide a valid id!',
    });
  }
  // responding to the request
  response.json({
    status: 'success',
    params,
    body,
    data: {
      tour: 'updated tour here bro',
    },
  });
};
exports.deleteTour = ({ params }, response) => {
  // checking that the things we need exist
  if (!params.id) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide an id!',
    });
  }
  // checking that the id is in range
  if (Number(params.id) > tours.length) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide a valid id!',
    });
  }
  // responding to the request
  response.status(204).json({
    status: 'success',
    params,
    data: null,
  });
};
```

### controllers/userController.js

```javascript
exports.getAllUsers = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.createUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.getUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.updateUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.deleteUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};
```

the flow is `app.js -> a router -> a controller`

it is good practice to extract server logic to its own file because you can have all your app config in one standalone file (app.js) and a general server file with things like db config, error handling, environment variables -- all that will live in the server.js file

```javascript
const app = require('./app');

const PORT = 4000;
app.listen(PORT, () => {
  console.log(`App running on port ${PORT}...`);
});
```

## Param middleware

Param middleware is middleware that runs only for certain parameters (when they are in the url)
Global middlewares take precedence over specific middleware

```javascript
const express = require('express');
const tourController = require('../controllers/tourController');
const router = express.Router();

// this will only run for routes with an id param in this route file
router.param('id', (req, res, next, paramValue) => {
  console.log(`Tour id is ${paramValue}`);
  next();
});

router
  .route('/')
  .get(tourController.getAllTours)
  .post(tourController.createTour);
router
  .route('/:id')
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(tourController.deleteTour);

module.exports = router;
```

In the above case we can take advantage of middleware to apply the DRY principle and simplify our checks for if an id exists!

```javascript
// in tourController.js
exports.checkId = (request, response, next, paramValue) => {
  console.log(`Tour id is ${paramValue}`);
  if (request.params.id * 1 > tours.length) {
    return response.status(404).json({
      status: 'Fail',
      reason: 'Invalid ID',
    });
  }
  next();
};
```

```javascript
// tourRoutes.js
router.param('id', tourController.checkId);
```

We could just create a function that just runs in every controller function but that goes against the philosophy of Express, which is to offload as many things as possible onto the middleware. Endpoint functions should only respond with data and should only ever receive valid requests

## Chaining middleware functions

You can chain middleware functions in order to do things like validate input

```javascript
exports.checkBody = (request, response, next) => {
  if (!request.body.name || !request.body.price) {
    return response.status(400).json({
      status: 'Fail',
      reason: 'Didnt provide a required parameter',
      requiredParameters: ['name', 'price'],
    });
  }
  next();
};
```

```javascript
router
  .route('/')
  .get(tourController.getAllTours)
  .post(tourController.checkBody, tourController.createTour);
```

You can also do things like check privileges, etc etc etc  
The handler should only ever do exactly what its meant to

## Serving static sites

In order to serve static content you have to serve it from an endpoint and use a builtin express middleware

Basic express intro done!

---

# Environment variables

Node and express apps can run in different environments

Like production or development

Might be using different DB's might have logging/debugging on/off

You define this with environment variables

A lot of packages depend on a node env variable

Easiest way is to just use the terminal

`NODE_ENV=development nodemon server.js`

You often use environment variables to define configuration settings and controlling sensitive data

Sometimes it starts being a lot so it becomes easier to make a config file

```
NODE_ENV=development
PORT=4000
USER=epimenov
PASSWORD=123456
```

```javascript
// in server.js
const dotenv = require('dotenv');
dotenv.config({ path: './config.env' });

const app = require('./app');

const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`App running on port ${port}...`);
});
```

command to get all necessary packages to get eslint and prettier choochin together

`npm i eslint prettier eslint-config-prettier eslint-plugin-prettier eslint-config-airbnb eslint-plugin-node eslint-plugin-import eslint-plugin-jsx-a11y eslint-plugin-react`

# MongoDB

## What is mongoDB?

Mongo is a NoSQL database, as opposed to Postgres or other SQL databases

In NoSQL, Tables are called collections (blog, users, reviews)  
In collections there are documents (rows) (post, user, review)  
Documents are structured as JSON

---

## Key features

- Document based - stores data in documents (field-value pair data structures)
- Scalable - easy to distribute data across multiple machines as users and data grows
- Flexible - no schema required, each document can have different number and type of fields
- Performant - embedded data models, indexing, sharding, flexible documents, native duplication, etc
- Free and open source, published under SSPL License

Mongo is arguably the most used db with node

---

## What the heck are documents anyway

Mongo uses a data format similar to JSON names BSON  
The difference is that in BSON data is typed  
Mongo stores data as fields as opposed to columns  
You can also have multiple values in one field and embed documents into other documents  
This is called embedding/denormalizing - including related data into a single document. This allows for quicker access and easier data models (may not always be the best solution howeever)  
In relational databases data is always normalized

In BSON the max size of a document is 16 MB  
Each document has a UID which acts as the primary key of that document

## CRUD operations

### Creating many

```
db.tours.insertMany([{name: "The Sea Explorer", price: 497, rating: 4.8},{name: "The Snow Adventurer", price: 997, rating: 4.9, difficulty: "easy"}])
```

### Advanced querying (reading)

see all documents  
`db.tours.find()`

see all documents that pass the filter object  
`db.tours.find({name: "The Forest Hiker"})`

see all documents with advanced queries  
`db.tours.find({price: {$lte: 500}})`

searching for two criteria at once  
`db.tours.find({price: {$lt: 500}, rating: {$gte: 4.8}})`

searching for two criteria with an or operator  
`db.tours.find({ $or: [ { price: { $lt: 500 } }, { rating: { $gte: 4.8 } } ] })`

searching for multiple critera and specifying what data to show  
`db.tours.find({ $or: [ { price: { $gt: 500 } }, { rating: { $gte: 4.8 } } ] }, {name: 1})`

---

### Updating

updating a document based on a filter  
`db.tours.updateOne({name: "The Snow Adventurer"}, {$set: {price: 597}})`

updating many documents based on a filter
`db.tours.updateMany({price: {$gt: 500}, rating: {$gte: 4.8}}, { $set: {premium: true }})`

### Deleting

`db.tours.deleteOne()`
`db.tours.deleteMany()`

---

# Configuring Mongoose in our application

```javascript
// in server.js
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const app = require('./app');

dotenv.config({ path: './config.env' });

const DB = process.env.DB_CONN_STRING.replace(
  '<PASSWORD>',
  process.env.DB_ADM_PASSWORD
);

mongoose
  .connect(DB, {
    useNewUrlParser: true,
    useCreateIndex: true,
    useFindAndModify: false,
  })
  .then(connection => {
    console.log(connection.connections);
    console.log(`MongoDB Connected!`);
  });

const port = process.env.PORT || 4000;
app.listen(port, () => {
  // eslint-disable-next-line no-console
  console.log(`App running on port ${port}...`);
});
```

## Why use mongoose

Mongoose is an object data modeling (ODM) library for mongo and node. It allows for rapid and simple development of mongo database interactions

Features

- Schemas to model data and relationships
- Easy data validation
- Simple query API
- Middleware
- ETC

We take the schema and mongoose feeds it into a model  
A schema is where we model our data by describing the structure, default values, and validation  
A model is a wrapper for the schema, that provides an interface to the database for CRUD ops

Making a schema and a model

```javascript
// in server.js
const tourSchema = new mongoose.Schema({
  name: {
    type: String,
    required: [true, 'No name specified'],
    unique: true,
  },
  rating: {
    type: Number,
    default: 4.5,
  },
  price: {
    type: Number,
    required: [true, 'No price specified'],
  },
});

const Tour = mongoose.model('Tour', tourSchema);
```

Creating a new tour and then saving it to the database

```javascript
// still in server.js
const testTour = new Tour({
  name: 'The Forest Hiker',
  rating: 4.7,
  price: 497,
});

testTour
  .save()
  .then(document => {
    console.log(document);
  })
  .catch(error => {
    console.log(error);
  });
```

# The Model View Controller (MVC) Architecture

The Model layer is concerned with all the business logic of the app
The Controller layer is concerned with app requests, model interaction and sending responses
The View layer is required if we have a graphical element to the app (SSR only), consists of templates used to generate the view

The benefit of MVC is that it is a lot more scalable

- Request is made to a router
- Router hands the request off to the controller
- Controller talks to the model
- Controller gets data from model
- Controller responds with the response

Application logic is the bones of what makes the app work (handling requests and responses)  
It is more focused on the technical aspects

Business logic is the code that actually solves the business problem we set out to solve  
Directly related to the needs of the client

Application logic should be kept in controllers  
Business logic should be kept in models

A common philosophy is fat models - lean controllers  
Basically, try to offload as much as possible onto the models

---

MVC Refactor happened here...

---

Only data provided by the schema will be the data that is actually sent to mongo

## Creating documents with mongoose

```javascript
exports.createTour = async (request, response) => {
  try {
    // Creating an instance of a Tour and then calling its methods
    // const newTour = new Tour({});
    // newTour.save();

    // Rawdogging it and calling the method off the parent
    const newTour = await Tour.create(request.body);

    response.status(201).json({
      status: 'success',
      data: {
        tour: newTour,
      },
    });
  } catch (error) {
    response.status(400).json({
      status: 'fail',
      message: 'Invalid data sent',
    });
  }
};
```

## Fully refactored controller file

```javascript
const Tour = require('../models/tourModel');

exports.getAllTours = async (request, response) => {
  try {
    const allTours = await Tour.find();

    response.json({
      status: 'success',
      results: allTours.length,
      data: { ...allTours },
    });
  } catch (error) {
    response.status(404).json({
      status: 'fail',
      reason: error,
    });
  }
};

exports.getTour = async (request, response) => {
  try {
    // Here the id is from the url
    // findById is just a helper function for findOne
    const tour = await Tour.findById(request.params.id);
    response.json({
      status: 'success',
      params: request.params,
      data: {
        tour,
      },
    });
  } catch (error) {
    response.status(404).json({
      status: 'fail',
      reason: error,
    });
  }
};

exports.createTour = async (request, response) => {
  try {
    // Creating an instance of a Tour and then calling its methods
    // const newTour = new Tour({});
    // newTour.save();

    // Rawdogging it and calling the method off the parent
    const newTour = await Tour.create(request.body);

    response.status(201).json({
      status: 'success',
      data: {
        tour: newTour,
      },
    });
  } catch (error) {
    response.status(400).json({
      status: 'fail',
      message: 'Invalid data sent',
      details: error,
    });
  }
};

exports.updateTour = async (request, response) => {
  try {
    const tour = await Tour.findByIdAndUpdate(request.params.id, request.body, {
      // respond with the updated document
      new: true,
      // run the validators on the new object
      runValidators: true,
    });

    response.json({
      status: 'success',
      params: request.params,
      body: request.body,
      data: {
        tour,
      },
    });
  } catch (error) {
    response.status(400).json({
      status: 'fail',
      message: 'Invalid data sent',
      details: error,
    });
  }
};

exports.deleteTour = async (request, response) => {
  try {
    await Tour.findByIdAndDelete(request.params.id);
    response.status(204).json({
      status: 'success',
      data: null,
    });
  } catch (error) {
    response.status(400).json({
      status: 'fail',
      error,
    });
  }
};
```

# Script to delete and reimport test data

```javascript
const fs = require('fs');
const mongoose = require('mongoose');
const dotenv = require('dotenv');
const Tour = require('../../models/tourModel');

dotenv.config({ path: './config.env' });

const DB = process.env.DB_CONN_STRING.replace(
  '<PASSWORD>',
  process.env.DB_ADM_PASSWORD
);

mongoose
  .connect(DB, {
    useNewUrlParser: true,
    useCreateIndex: true,
    useFindAndModify: false,
    useUnifiedTopology: true,
  })
  .then(connection => {
    console.log(`MongoDB Connected!`);
  });

// READ JSON FILE
const tours = JSON.parse(
  fs.readFileSync(`${__dirname}/tours-simple.json`, 'utf-8')
);

// IMPORT DATA INTO DATABASE
const importData = async () => {
  try {
    await Tour.create(tours);
    console.log(`Data successfully loaded!`);
  } catch (error) {
    console.log(error);
  }
  process.exit();
};

// DELETE ALL DATA FROM COLLECTION

const deleteData = async () => {
  try {
    await Tour.deleteMany();
    console.log(`Data deleted!`);
  } catch (error) {
    console.log(error);
  }
  process.exit();
};

if (process.argv[2] === '--import') {
  importData();
} else if (process.argv[2] === '--delete') {
  deleteData();
}
```

---

# Filtering

You can implement filtering pretty easily with mongoose and express

Two ways of writing filtering

Either with filter object or with mongoose methods

### Plain jane

```javascript
const allTours = await Tour.find({
  duration: request.query.duration,
  difficulty: request.query.difficulty,
});
```

### With mongoose

```javascript
const allTours = await Tour.find()
  .where('duration')
  .equals(request.query.duration)
  .where('difficulty')
  .equals(request.query.difficulty);
```

These solutions are really trivial and would break if we added pagination and the like

### Adding exclusion terms for the query strings

```javascript
const queryObj = { ...request.query };
const excludedFields = ['page', 'sort', 'limit', 'fields'];
excludedFields.forEach(element => delete queryObj[element]);

console.log(request.query, queryObj);

const allTours = await Tour.find(queryObj);
```

We have to build the query object before executing it in order to enable us to do the more fancy search stuff

```javascript
// BUILD QUERY
const queryObj = { ...request.query };
const excludedFields = ['page', 'sort', 'limit', 'fields'];
excludedFields.forEach(element => delete queryObj[element]);

console.log(request.query, queryObj);

const query = Tour.find(queryObj);

// using mongoose to execute the search
// const query = Tour.find()
//   .where('duration')
//   .equals(request.query.duration)
//   .where('difficulty')
//   .equals(request.query.difficulty);

// EXECUTE QUERY
const allTours = await query;
```

# Implementing filtering

One way to specify things like greater than, less than is to use brackets in the

## Advanced filtering

```javascript
exports.getAllTours = async (request, response) => {
  try {
    // BUILD QUERY
    const queryObj = { ...request.query };
    const excludedFields = ['page', 'sort', 'limit', 'fields'];
    excludedFields.forEach(element => delete queryObj[element]);

    console.log(request.query, queryObj);

    let queryString = JSON.stringify(queryObj);
    queryString = queryString.replace(
      /\b(gte|gt|lte|lt)\b/g,
      matchedTerm => `$${matchedTerm}`
    );

    console.log(JSON.parse(queryString));

    //  {difficulty: 'easy', duration: { $gte:5 }}

    const query = Tour.find(JSON.parse(queryString));
    // using mongoose to execute the search
    // const query = Tour.find()
    //   .where('duration')
    //   .equals(request.query.duration)
    //   .where('difficulty')
    //   .equals(request.query.difficulty);

    // EXECUTE QUERY
    const allTours = await query;

    // SEND RESPONSE
    response.json({
      status: 'success',
      results: allTours.length,
      data: { ...allTours },
    });
  } catch (error) {
    response.status(404).json({
      status: 'fail',
      reason: error,
    });
  }
};
```

## Sorting

passing a sort param with a minus will sort by descending, passing it without will sort by ascending

to sort by several arguments simply combine them in a string separated by spaces

simple sort

```javascript
if (request.query.sort) {
  query = query.sort(request.query.sort);
}
```

multiple sort

```javascript
if (request.query.sort) {
  const sortBy = request.query.sort.split(',').join(' ');
  query = query.sort(sortBy);
}
```

giving a default sort

```javascript
if (request.query.sort) {
  const sortBy = request.query.sort.split(',').join(' ');
  query = query.sort(sortBy);
} else {
  query = query.sort('-createdAt');
}
```

## Limiting

Limiting lets clients select which fields they get in response to minimize bandwidth

`http://localhost:4000/api/v1/tours?fields=name,duration,difficulty,price`

```javascript
if (request.query.fields) {
  // create a string of selected fields and process it
  const fields = request.query.fields.split(',').join(' ');
  query = query.select(fields);
} else {
  // exclude the v field
  query.select('-__v');
}
```

You can also exclude fields right in the schema with `select: false`
