# Natours build notes

## Express

Express is a minimal node framework thats built on node using node code

Has a very robust set of features

- complex routing
- easier handling of requests and responses
- middleware
- ssr

this saves us the trouble of having to reinvent the wheel when we config an api

express also makes it easier to organize our app into an mvc architecture

it is convention to configure all of express in app.js

Initializing express

```javascript
const express = require('express');

const app = express();

const PORT = 4000;

app.listen(PORT, () => {
  console.log(`App running on port ${PORT}...`);
});
```

basic route

```javascript
app.get('/', (request, response) => {
  response.status(200).send('Hello from the server side!');
});
```

sending json instead of plain text

```javascript
app.get('/', (request, response) => {
  response.status(200).json({
    message: `Hello from the server side!`,
    app: 'Natours',
  });
});
```

the http 200 response is default so you dont have to explicitly set it

also the json method automatically sets the header to app/json

## APIs and RESTful API design

An API is a piece of software that is used by another piece of software to allow apps to talk to each other

So it's a facilitator application

This can mean a Web API, or something smaller like `fs` or `http`, the DOM JS API, publicly exposed methods in oop, etc etc

### REST stands for REpresentational State Transfer

It's a logical way of building API's making them easy to consume

- Separate API into logical resources
  - Key abstraction of info in REST
  - A resource is an object or representation of something with some data associated to it
  - i.e. tours, users, reviews (all nouns)
- Exposed them via structured, resource-based URLS,
  - endpoints should only contain resources and not the actions to be performed on them
  - i.e. instead of `/getTour` use `/tours` with a `GET` method
  - common verbs are GET, POST, DELETE, PATCH (only supply whats been changed), PUT (send the entire object)
- Use the right HTTP methods (verbs)
  - Follow the CRUDL operations if possible
- Send data as JSON where possible
  - Nice for both computers and humans to understand
  - Expandable with things like JSend (envelops data to imporove security and make response status explicit)
- Be stateless
  - All state is handled on the client and not on the server
  - Like loggedIn or currentPage
  - So all information to process the request must be included in it
  - The server shouldnt keep anything in memory
  - i.e. instead of making the server track what the currentpage is, request pages explicitly

The request data holds what was sent but Express cant access it by default so we need middleware -- add `app.use(express.json())` to get express to receive the body

## The request-response cycle

- Our app receives a request
- It generates a request and a response object
- We use middleware to process the request (like `express.json` (aka bodyparser))
- The order of middlewares in the stack is defined by their order in the code

```javascript
// adding an additional function to the middleware stack
app.use((req, res, next) => {
  // we get access to the request, response, and the next function
  console.log('Hello from our custom middleware ðŸ’©');
  // without calling the next function the flow would hang
  next();
});
```

When middleware is declared globally it will run everywhere but it is possible to have middleware run for only specific route handlers, depending when the middleware is declared

```javascript
// faster way of declaring routes than above
// declare the endpoint and then chain all applicable methods
app.route('/api/v1/tours').get(getAllTours).post(createTour);
app.use((req, res, next) => {
  // we get access to the request, response, and the next function
  console.log('Hello from our custom middleware ðŸ’©');
  // without calling the next function the flow would hang
  next();
});
app
  .route('/api/v1/tours/:id')
  .get(getTour)
  .patch(updateTour)
  .delete(deleteTour);
```

route handlers typically are at the end of the request response cycle so the custom middleware is not used

adding additional data to the request object to be consumed at a later point

```javascript
// manipulating the request object
app.use((req, res, next) => {
  // appending the time of the request to the request
  // @ts-ignore
  req.currentTime = new Date().toISOString();
  next();
});

const getAllTours = (request, response) => {
  console.log(request.currentTime);
  response.json({
    status: 'success',
    requestedAt: request.currentTime,
    results: tours.length,
    data: {
      tours,
    },
  });
};
```

refactoring our routes to use dedicated routers

```javascript
// before
app.route('/api/v1/tours').get(getAllTours).post(createTour);

app
  .route('/api/v1/tours/:id')
  .get(getTour)
  .patch(updateTour)
  .delete(deleteTour);

// after
const tourRouter = express.Router();
app.use('/api/v1/tours', tourRouter);
tourRouter.route('/').get(getAllTours).post(createTour);
tourRouter.route('/:id').get(getTour).patch(updateTour).delete(deleteTour);
```

this kind of refactoring is called router mounting

end result:

```javascript
const tourRouter = express.Router();
const userRouter = express.Router();

tourRouter.route('/').get(getAllTours).post(createTour);
tourRouter.route('/:id').get(getTour).patch(updateTour).delete(deleteTour);
userRouter.route('/').get(getAllUsers).post(createUser);
userRouter.route('/:id').get(getUser).patch(updateUser).delete(deleteUser);

app.use('/api/v1/tours', tourRouter);
app.use('/api/v1/users', userRouter);
```

## MVC-ifying our app

MVC will be covered at a later date but what this does is break out all our logic into separate files

### New app.js

```javascript
const express = require('express');
const morgan = require('morgan');

// Importing routers
const tourRouter = require('./routes/tourRoutes');
const userRouter = require('./routes/userRoutes');

// Initializing application
const app = express();

// MIDDLEWARES -- DECLARE ALL YOUR MIDDLEWARE HERE FOR GLOBAL MIDDLEWARE
app.use(express.json());
app.use(morgan('dev'));
app.use((req, res, next) => {
  console.log('Hello from our custom middleware ðŸ’©');
  next();
});
app.use((req, res, next) => {
  // appending the time of the request to the request
  // @ts-ignore
  req.currentTime = new Date().toISOString();
  next();
});

// Mounting routers -- YES THIS IS ALSO MIDDLEWARE
app.use('/api/v1/tours', tourRouter);
app.use('/api/v1/users', userRouter);

// SERVER
const PORT = 4000;
app.listen(PORT, () => {
  console.log(`App running on port ${PORT}...`);
});
```

### routes/tourRoutes.js

```javascript
const express = require('express');
const tourController = require('../controllers/tourController');
const router = express.Router();

router
  .route('/')
  .get(tourController.getAllTours)
  .post(tourController.createTour);
router
  .route('/:id')
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(tourController.deleteTour);

module.exports = router;
```

### routes/userRoutes.js

```javascript
const express = require('express');
const userController = require('../controllers/userController');

const router = express.Router();

router
  .route('/')
  .get(userController.getAllUsers)
  .post(userController.createUser);
router
  .route('/:id')
  .get(userController.getUser)
  .patch(userController.updateUser)
  .delete(userController.deleteUser);

module.exports = router;
```

### controllers/tourController.js

```javascript
const fs = require('fs');

// all the router logic at this point has been extracted to its own file
const tours = JSON.parse(
  // @ts-ignore
  fs.readFileSync(`${__dirname}/../dev-data/data/tours-simple.json`)
);

exports.getAllTours = (request, response) => {
  console.log(request.currentTime);
  response.json({
    status: 'success',
    requestedAt: request.currentTime,
    results: tours.length,
    data: {
      tours,
    },
  });
};
exports.getTour = (request, response) => {
  const { params } = request;
  const tour = tours.find(element => element.id === Number(params.id));
  // controlling for insane request
  // general catch for if an id doesnt come back
  if (!tour) {
    return response.status(404).json({
      status: 'fail',
      reason: 'Invalid ID',
    });
  }
  // deterministically checking for an out of range id
  if (Number(params.id) > tours.length) {
    return response.status(404).json({
      status: 'fail',
      reason: 'id is not valid, probably too high!',
    });
  }
  // actually processing and responding if the checks pass
  response.json({
    status: 'success',
    params,
    data: {
      tour,
    },
  });
};
exports.createTour = (request, response) => {
  // first thing is to figure out the id of the object, since the db wont do it for us here
  // figuring out the id based on the length of the tours array
  const newId = tours[tours.length - 1].id + 1;
  // merging together an adhoc object and the request.body
  const newTour = Object.assign({ id: newId }, request.body);
  // pushing new item into tours array
  tours.push(newTour);
  // writing the new array to file
  fs.writeFile(
    `${__dirname}/dev-data/data/tours-simple.json`,
    // supplying a stringified version of the object as data
    JSON.stringify(tours),
    // once the write is complete, we send a response indicating it is done
    error => {
      response.status(201).json({
        status: 'success',
        data: {
          tour: newTour,
        },
      });
    }
  );
};
exports.updateTour = ({ params, body }, response) => {
  // checking that the things we need exist
  if (!params || !body) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide params and a body!',
    });
  }
  // checking that the id is in range
  if (Number(params.id) > tours.length) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide a valid id!',
    });
  }
  // responding to the request
  response.json({
    status: 'success',
    params,
    body,
    data: {
      tour: 'updated tour here bro',
    },
  });
};
exports.deleteTour = ({ params }, response) => {
  // checking that the things we need exist
  if (!params.id) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide an id!',
    });
  }
  // checking that the id is in range
  if (Number(params.id) > tours.length) {
    return response.status(404).json({
      status: 'fail',
      reason: 'please provide a valid id!',
    });
  }
  // responding to the request
  response.status(204).json({
    status: 'success',
    params,
    data: null,
  });
};
```

### controllers/userController.js

```javascript
exports.getAllUsers = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.createUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.getUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.updateUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};

exports.deleteUser = (request, response) => {
  response.status(500).json({
    status: 'error',
    reason: 'endpoint not yet implemented',
  });
};
```

the flow is `app.js -> a router -> a controller`

it is good practice to extract server logic to its own file because you can have all your app config in one standalone file (app.js) and a general server file with things like db config, error handling, environment variables -- all that will live in the server.js file

```javascript
const app = require('./app');

const PORT = 4000;
app.listen(PORT, () => {
  console.log(`App running on port ${PORT}...`);
});
```

## Param middleware

Param middleware is middleware that runs only for certain parameters (when they are in the url)
Global middlewares take precedence over specific middleware

```javascript
const express = require('express');
const tourController = require('../controllers/tourController');
const router = express.Router();

// this will only run for routes with an id param in this route file
router.param('id', (req, res, next, paramValue) => {
  console.log(`Tour id is ${paramValue}`);
  next();
});

router
  .route('/')
  .get(tourController.getAllTours)
  .post(tourController.createTour);
router
  .route('/:id')
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(tourController.deleteTour);

module.exports = router;
```

In the above case we can take advantage of middleware to apply the DRY principle and simplify our checks for if an id exists!

```javascript
// in tourController.js
exports.checkId = (request, response, next, paramValue) => {
  console.log(`Tour id is ${paramValue}`);
  if (request.params.id * 1 > tours.length) {
    return response.status(404).json({
      status: 'Fail',
      reason: 'Invalid ID',
    });
  }
  next();
};
```

```javascript
// tourRoutes.js
router.param('id', tourController.checkId);
```

We could just create a function that just runs in every controller function but that goes against the philosophy of Express, which is to offload as many things as possible onto the middleware. Endpoint functions should only respond with data and should only ever receive valid requests

## Chaining middleware functions

You can chain middleware functions in order to do things like validate input

```javascript
exports.checkBody = (request, response, next) => {
  if (!request.body.name || !request.body.price) {
    return response.status(400).json({
      status: 'Fail',
      reason: 'Didnt provide a required parameter',
      requiredParameters: ['name', 'price'],
    });
  }
  next();
};
```

```javascript
router
  .route('/')
  .get(tourController.getAllTours)
  .post(tourController.checkBody, tourController.createTour);
```

You can also do things like check privileges, etc etc etc  
The handler should only ever do exactly what its meant to

## Serving static sites

In order to serve static content you have to serve it from an endpoint and use a builtin express middleware

Basic express intro done!

---

# Environment variables

Node and express apps can run in different environments

Like production or development

Might be using different DB's might have logging/debugging on/off

You define this with environment variables

A lot of packages depend on a node env variable

Easiest way is to just use the terminal

`NODE_ENV=development nodemon server.js`

You often use environment variables to define configuration settings and controlling sensitive data

Sometimes it starts being a lot so it becomes easier to make a config file

```
NODE_ENV=development
PORT=4000
USER=epimenov
PASSWORD=123456
```

```javascript
// in server.js
const dotenv = require('dotenv');
dotenv.config({ path: './config.env' });

const app = require('./app');

const port = process.env.PORT || 4000;
app.listen(port, () => {
  console.log(`App running on port ${port}...`);
});
```
