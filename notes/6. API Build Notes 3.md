# Mongo Data Modeling

One of the hardest parts of development is correctly modeling data

Data modeling is the process of taking data from a real world scenario and turning it into a structured and logical data model

In an example of an online shop theres a lot of sets of data that need to be modeled

So we turn that jumble into a set of logical data sets and connections between the data

Data modeling is not always straightforward and there isnt always a right answer

- Identify types of relationships between data
- Understand referencing vs embedding
- Understand when to reference vs embed
- Understand types of referencing

## Types of relationships

- One to One
  - Movie can only have one name
- One to Many (1:FEW/1:MANY/1:LOADS)
  - Movie can win a few awards (1:10-100s)
  - Movie can have many reviews (1:1000-10000s)
  - Apps can have tons of log events (if something can expand indefinitely its a 1:LOADS)
- Many to Many
  - Many movies can have many various actors in them

## Referencing vs Embedding

Referencing is when you list the id of the object you want to reference in your document
Embedding is when the contained document is embedded in the parent document from the start

Normalized documents can be denormalized at will but not the other way around

If you have datasets that are inextricably linked, use embedding
If you have datasets that need to be referenced on their own, use referencing

## When to embed vs when to reference

|        Criterion        |                   Embedding                    |       Referencing        |
| :---------------------: | :--------------------------------------------: | :----------------------: |
|    Relationship type    |                  1:FEW/1:MANY                  | 1:MANY/1:LOADS/MANY:MANY |
| How often data is read  |             Read/Write ratio high              |   Read/Write ratio low   |
| How related is the data | Doesnt make sense to query the data separately |           Does           |

## Types of referencing

- Child referencing
  - Parent is aware of all of its children
  - Child doesnt know about its parent
  - Tightly couples parent and children
- Parent referencing
  - Parent doesnt know about all of its children
  - Child is aware of its parent
- Two-way referencing
  - Parent is aware of all of its children
  - Child is aware of all of its parents

Generally the more skewed the relationship the more parent referencing makes sense

BSON documents are limited to 16MB so minimizing the amount of data resulting from a query is a good idea

Never allow an array in a document to grow indefinitely

## Summary

- Structure the data to match the ways that your applicaiton will query and update data. In other words, identify the questions that arise from your application's use cases and then model your data so that the questions get answered in the most efficient way
- Generally, favor embedding unless there is a good reason not to embed
- 1:TON or MANY:MANY is a good reason to reference or when the data is updated a lot or needs to be accessed on its own
- Use embedding when data is read a lot but not updated a lot, or when two datasets belong together intrinsically
- Dont allow an array to grow indefinitely
- Use two-way referencing in many:many relationships

# Code notes

Creating embedded documents (using arrays)

```javascript
    startLocation: {
      // GeoJSON
      type: {
        type: String,
        default: 'Point',
        enum: ['Point'],
      },
      coordinates: [Number],
      address: String,
      desscription: String,
    },
    locations: [
      {
        type: {
          type: String,
          default: 'Point',
          enum: ['Point'],
        },
        coordinates: [Number],
        address: String,
        description: String,
        day: Number,
      },
    ],
```

Embedding user documents into tour documents

```javascript
// /* ---------- Populate the guides and embed them into the document ------- */
tourSchema.pre("save", async function (next) {
  const guidesPromises = this.guides.map((guideId) => User.findById(guideId));
  this.guides = await Promise.all(guidesPromises);
  next();
});
```

Setting up references in a model

```javascript
    guides: [
      {
        type: mongoose.Schema.ObjectId,
        ref: 'User',
      },
    ],
```

Populating the data

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
  const tour = await Tour.findById(request.params.id).populate({
    path: "guides",
    select: "-__v -passwordChangedAt",
  });

  if (!tour) {
    return next(new AppError("Requested tour does not exist", 404));
  }

  response.json({
    status: "success",
    params: request.params,
    data: {
      tour,
    },
  });
});
```

Since we'd like to populate this data everywhere, we will extract it to a query middleware

```javascript
tourSchema.pre(/^find/, function (next) {
  this.populate({
    path: "guides",
    select: "-__v -passwordChangedAt",
  });
  next();
});
```

Populating referenced data is extremely powerful

## Creating the review model

```javascript
const mongoose = require("mongoose");

const reviewSchema = new mongoose.Schema(
  {
    review: {
      type: String,
      required: [true, "Review cannot be empty"],
    },
    rating: {
      type: Number,
      min: 1,
      max: 5,
    },
    createdAt: {
      type: Date,
      default: Date.now(),
    },
    tour: {
      type: mongoose.Schema.ObjectId,
      ref: "Tour",
      required: [true, "Review must belong to a tour"],
    },
    user: {
      type: mongoose.Schema.ObjectId,
      ref: "User",
      required: [true, "Review must belong to a user"],
    },
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

const Review = mongoose.model("Review", reviewSchema);

module.exports = Review;
```

### reviewController.js

```javascript
const Review = require("../models/reviewModel");
const catchAsync = require("../utils/catchAsync");

/* ---------------------------- Create new review --------------------------- */
exports.createReview = catchAsync(async (request, response, next) => {
  const newReview = await Review.create(request.body);

  response.status(201).json({
    status: "success",
    data: {
      review: newReview,
    },
  });
});

/* ----------------------------- Get all reviews ---------------------------- */
exports.getAllReviews = catchAsync(async (request, response, next) => {
  const allReviews = await Review.find();

  response.json({
    status: "success",
    reviews: allReviews,
  });
});
```

### reviewRoutes.js

```javascript
const express = require("express");
const authController = require("../controllers/authController");
const reviewController = require("../controllers/reviewController");

const router = express.Router();

router
  .route("/")
  .get(reviewController.getAllReviews)
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );

module.exports = router;
```

## Populating user and tour data onto the reviews

```javascript
reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "tour",
  });
  next();
});

reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "user",
  });
  next();
});
```

You can also chain populates inside of one middleware function

## Virtual populate

Virtual populate is a somewhat advanced feature in mongo

We've engineered parent referencing on the reviews to the tours, so how can we go about it in the other direction?

- We could query for reviews when we query for tours or child reference on each tour document
- We can also use Virtual Populate

With VP we can populate the tours with reviews without keeping an array of id's on the tour

```javascript
tourSchema.virtual("reviews", {
  ref: "Review", // identifying the model to reference
  foreignField: "tour", // the foreign reference where to go looking
  localField: "_id", // what to go looking for in the other model
});
```

Its important to avoid cascading population however

```javascript
// reviewSchema.pre(/^find/, function (next) {
//   this.populate({
//     path: 'tour',
//     select: 'name',
//   });
//   next();
// });

// reviewSchema.pre(/^find/, function (next) {
//   this.populate({
//     path: 'user',
//   });
//   next();
// });

reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "user",
    select: "name photo",
  });
  next();
});
```

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
  const tour = await Tour.findById(request.params.id).populate("reviews");

  if (!tour) {
    return next(new AppError("Requested tour does not exist", 404));
  }

  response.json({
    status: "success",
    params: request.params,
    data: {
      tour,
    },
  });
});
```

---

# Simple Nested Routes

Consider the practical aspect of how you want to create a review

It is impractical to hand feed object id's in production

The user id should come from the currently logged in user, and the tour id should come from the current tour

When submitting a review you want to submit a review like this

`POST /tour/234trega/reviews`

This above is a parent route, which makes a lot of sense in the context of clearly defined parent child relationships

The url should write to the reviews resource on the post resource

`GET /tour/234trega/reviews`

Get us all the reviews from the tour

`GET /tour/234trega/reviews/546ojrgkalr`

Get a specific review on the tour

```javascript
// in tourRoutes.js
router
  .route("/:tourId/reviews")
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );
```

```javascript
// in reviewController.js
exports.createReview = catchAsync(async (request, response, next) => {
  // Allow nested routes by defining these args when they're not there
  if (!request.body.tour) request.body.tour = request.params.tourId;
  if (!request.body.user) request.body.user = request.user.id; // the user object comes from protect
  const newReview = await Review.create(request.body);

  response.status(201).json({
    status: "success",
    data: {
      review: newReview,
    },
  });
});
```

# Nesting routes with Express

Express has an advanced feature to nest routes

The problem with the above implementation is that it is messy, because a review route is now in the tour router and we're doubling up on routes

We can use mergeparams and using routers inside routers

By default each router only has access to the parameters of its own specific route

So to allow sharing of params set mergeParams to true

```javascript
const express = require("express");
const tourController = require("../controllers/tourController");
const authController = require("../controllers/authController");
const reviewRouter = require("./reviewRoutes");

const router = express.Router();

// if you ever see a url like this, hand it off to the reviewRouter
router.use("/:tourId/reviews", reviewRouter);

router
  .route("/top-5-cheap")
  .get(tourController.aliasTopTours, tourController.getAllTours);

router.route("/tour-stats").get(tourController.getTourStats);

router.route("/monthly-plan/:year").get(tourController.getMonthlyPlan);

router
  .route("/")
  .get(authController.protect, tourController.getAllTours)
  .post(tourController.createTour);
router
  .route("/:id")
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(
    authController.protect,
    authController.restrictTo("admin", "lead-guide"),
    tourController.deleteTour
  );

module.exports = router;
```

```javascript
const express = require("express");
const authController = require("../controllers/authController");
const reviewController = require("../controllers/reviewController");

const router = express.Router({ mergeParams: true });

router
  .route("/")
  .get(reviewController.getAllReviews)
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );

module.exports = router;
```

## Nested GET Endpoint

```javascript
exports.getAllReviews = catchAsync(async (request, response, next) => {
  // if a tourId param exists, set the filter to respond with just the reviews
  // of that tour
  let filter = {};
  if (request.params.tourId) filter = { tour: request.params.tourId };

  const allReviews = await Review.find(filter);

  response.json({
    status: "success",
    reviews: allReviews,
  });
});
```

# Factory functions

Factory functions are functions that return functions, in our case to perform CRUDL ops

## DELETE

`In handlerFactory.js`

```javascript
const catchAsync = require("../utils/catchAsync");
const AppError = require("../utils/appError");

exports.deleteOne = (Model) =>
  catchAsync(async (request, response, next) => {
    const doc = await Model.findByIdAndDelete(request.params.id);

    if (!doc) {
      return next(new AppError("No document found with id", 404));
    }

    response.status(204).json({
      status: "success",
      data: null,
    });
  });
```

The idea is to generalize our functions to avoid repeating code, since the operations are fundamentally similar across all controllers

`In tourController.js`

```javascript
exports.deleteTour = factory.deleteOne(Tour);
// exports.deleteTour = catchAsync(async (request, response, next) => {
//   const tour = await Tour.findByIdAndDelete(request.params.id);

//   if (!tour) {
//     return next(new AppError('Requested tour does not exist', 404));
//   }

//   response.status(204).json({
//     status: 'success',
//     data: null,
//   });
// });
```

did this in the other controllers too

## CREATE/UPDATE

```javascript
exports.updateOne = (Model) =>
  catchAsync(async (request, response, next) => {
    const doc = await Model.findByIdAndUpdate(request.params.id, request.body, {
      new: true,
      runValidators: true,
    });

    if (!doc) {
      return next(new AppError("No document found with that id", 404));
    }

    response.status(200).json({
      status: "success",
      data: { doc },
    });
  });
```

not all controller functions can be extracted to the factory, but the basic repetitive ones can be~

extracting setting the tour and user id's to a middleware

```javascript
exports.setTourUserIds = (request, response, next) => {
  // Allow nested routes by defining these args when they're not there
  if (!request.body.tour) request.body.tour = request.params.tourId;
  if (!request.body.user) request.body.user = request.user.id; // the user object comes from protect
  next();
};

// don't forget to call the middleware in the route

exports.createReview = factory.createOne(Review);
```

## Using middleware to maximize utility of factory functions

```javascript
/* ----------------------- VIEW OWN INFO (MIDDLEWARE) ----------------------- */
exports.getMe = (request, response, next) => {
  request.params.id = request.user.id;
  next();
};
```

```javascript
router.get(
  "/me",
  authController.protect,
  userController.getMe,
  userController.getUser
);
```

## Fixing auth on resources

Tours are the core product that we serve to the public so it does not make sense to make the tours api protected if we want other websites to display our tours. Also only admins and lead guides should have rights to editing tours so we will restrict it to them

```javascript
const express = require("express");
const userController = require("../controllers/userController");
const authController = require("../controllers/authController");

const router = express.Router();

router.post("/signup", authController.signUp);
router.post("/login", authController.login);
router.post("/forgot-password", authController.forgotPassword);
router.patch("/reset-password/:token", authController.resetPassword);

// ⬇️ All middleware after this call is blanket protected
router.use(authController.protect);

router.get("/me", userController.getMe, userController.getUser);
router.patch("/update-data", userController.updateMe);
router.patch("/update-password", authController.updatePassword);
router.delete("/delete-me", userController.deleteMe);

router.use(authController.restrictTo("admin"));

router
  .route("/")
  .get(userController.getAllUsers)
  .post(userController.createUser);

router
  .route("/:id")
  .get(userController.getUser)
  .patch(userController.updateUser)
  .delete(userController.deleteUser);

module.exports = router;
```

## Optimizing read performance in mongoDB

Read performance is really important in mongodb

In large scale datasets it is important to use indexes because in a find operation all documents are evaluated

Indexing allows us to extract ordered indices with pared down data to find data much more efficiently

```javascript
tourSchema.index({
  // 1 is sort ascending, -1 is sort descending
  price: 1,
});
```

Indexes may or may not be unique, requiring a field be unique in the model will trigger indexing automatically

If we query data together frequently compound indexes make sense as well

```javascript
tourSchema.index({
  // 1 is sort ascending, -1 is sort descending
  price: 1,
  ratingsAverage: 1,
});
```

You need to study the access patterns of what data is accessed the most and set your indexes appropriately

You don't want to blindly index everything and just hope for the best, because at the end of the day indexes consume storage resources and computational resources (indexes need to be refreshed anytime a document in a collection is updated)

```javascript
tourSchema.index({
  slug: 1,
});
```

## Calculating statistics on tour

Summarizing a related data set on the main data set is common. It makes sense to store the average rating and amount of ratings on the tours instead of querying reviews multiple times over for each tour

We will use a static method on the schema, instead of an instance method

In static methods the this keyword points to the model

In reviewModel.js

```javascript
reviewSchema.pre("save", function (next) {
  // You cannot call the static method by using Review.blahblah
  // So use this.constructor

  this.constructor.calcAverageRatings(this.tour);
  next();
});

reviewSchema.statics.calcAverageRatings = async function (tourID) {
  const stats = await this.aggregate([
    {
      $match: { tourID },
    },
    {
      $group: {
        _id: "$tour",
        nRatings: { $sum: 1 },
        avgReview: { $avg: "$rating" },
      },
    },
  ]);
  console.log(stats);
};
```

Jonas made a booboo above, you're supposed to use post, not pre

```javascript
reviewSchema.post("save", function () {
  // You cannot call the static method by using Review.blahblah
  // So use this.constructor

  this.constructor.calcAverageRatings(this.tour);
});

reviewSchema.statics.calcAverageRatings = async function (tourID) {
  const stats = await this.aggregate([
    {
      $match: { tour: tourID },
    },
    {
      $group: {
        _id: "$tour",
        nRatings: { $sum: 1 },
        avgReview: { $avg: "$rating" },
      },
    },
  ]);
  console.log(stats);

  await Tour.findByIdAndUpdate(tourID, {
    ratingsQuantity: stats[0].nRating,
    ratingsAverage: stats[0].avgRating,
  });
};
```

This above is all well and good if users are posting new reviews but we also need to be able to handle users modifying their reviews or deleting

## Calculating statistics after deletes, edits, etc

for commands like findByIdAndUpdate and Delete we do not have document middleware, just query middleware.

simply put we dont have access to the document

but there's a way around this

```javascript
reviewSchema.pre(/^findOneAnd/, async function (next) {
  // in this context the this keyword is the query not the document
  // so we just run findOne
  this.r = await this.findOne();
  console.log(this.r);
  next();
  // We need to ensure we are using relevant data to calculate ratings
  // You cant change this to a post function because we lose access to the query
});

reviewSchema.post(/^findOneAnd/, async function () {
  // In order to maintain state we assign the result of the query to this
  // also in this case the method is nested even deeper
  await this.r.constructor.calcAverageRatings(this.r.tour);
});
```

Remember that if the last review on a tour is deleted you get 0 reviews and that will cause an error when trying to calculate reviews, owing to how we are accessing the data. The solution is to check if the length is greater than 0 before calculating averages, and setting a default if there are no reviews.

# IMPORTANT: REFERENCE ABOVE FOR ACCESSING THE DOCUMENT WITHIN QUERY MIDDLEWARE

# Preventing duplicate reviews

Users realistically should only be able to write one review per tour

So we will write some code to prevent review bombing, with indexes

```javascript
reviewSchema.index(
  {
    tour: 1,
    user: 1,
  },
  {
    unique: true,
  }
);
```

now each combination of tour and user for review must be unique

note that if you implement this it only 'clicks' for newly created tours and users, so you need to lay the foundation for this right away or clobber your database

## Rounding the rating

It's possible to get a rating value that has a lot of decimal places, so we are going to use a setter function to round it to one decimal place

```javascript
    ratingsAverage: {
      type: Number,
      default: 4.5,
      min: [1, 'Rating cannot be lower than 1.0'],
      max: [5, 'Rating cannot be greater than 5.0'],
      set: currentValue => Math.round(currentValue * 10) / 10,
    },
```

# Geospatial queries

```javascript
router
  .route("/tours-within/:distance/center/:latlng/unit/:unit")
  .get(tourController.getToursWithin);
```

Indexing must be on for geospatial queries

```javascript
tourSchema.index({
  startLocation: "2dsphere",
});
```

```javascript
exports.getToursWithin = catchAsync(async (request, response, next) => {
  const { distance, latlng, unit } = request.params;
  const [lat, lng] = latlng.split(",");

  const radius = unit === "mi" ? distance / 3963.2 : distance / 6378.1;

  if (!lat || !lng) {
    next(
      new AppError(
        "Please provide a latitude and a longitude in the format of lat,lng",
        400
      )
    );
  }

  console.log(distance, lat, lng, unit);

  const tours = await Tour.find({
    startLocation: { $geoWithin: { $centerSphere: [[lng, lat], radius] } },
  });

  response.status(200).json({
    status: "success",
    results: tours.length,
    data: {
      data: tours,
    },
  });
});
```

reference the operators page in mongo docs for more information

## Calculating distances

`router.route('/distances/:latlng/unit/:unit').get(tourController.getDistances);`

```javascript
exports.getDistances = catchAsync(async (request, response, next) => {
  const { latlng, unit } = request.params;
  const [lat, lng] = latlng.split(",");

  if (!lat || !lng) {
    next(
      new AppError(
        "Please provide a latitude and a longitude in the format of lat,lng",
        400
      )
    );
  }

  const distances = await Tour.aggregate([
    {
      $geoNear: {
        near: {
          type: "Point",
          coordinates: [lng * 1, lat * 1],
        },
        distanceField: "distance",
        distanceMultiplier: 0.001,
      },
    },
    {
      $project: {
        distance: 1,
        name: 1,
      },
    },
  ]);

  response.status(200).json({
    status: "success",
    data: {
      data: distances,
    },
  });
});
```

# SSR With Pug

## Basic

For this course we will use Pug

Pug works out of the box with express so all we need to do is set it in the express instance in app.js

```javascript
app.set("view engine", "pug");
app.set("views", path.join(__dirname, "views"));
```

setting up the basic pug template

```pug
h1 The Park Camper
```

mounting the route just above the api router mounting

```javascript
app.get("/", (req, res) => {
  res.status(200).render("base");
});
```

turns out we actually do need to install pug

`npm i pug`

## First steps with pug

Pug is a whitespace sensitive syntax for writing html

We write the name and indentation in the code, and thats it

Regular html is fine in pug btw

When you reference linked files it will go looking in the public folder because we defined the static assets folder as the folder named public

To transfer variables to the pug template add the object of things to render as the second argument to the render() function

```javascript
app.get("/", (req, res) => {
  res.status(200).render("base", {
    tour: "The Forest Hiker",
    user: "eugene",
  });
});
```

```pug
doctype html
html
	head
		title Natours
		link(rel='stylesheet' href='css/style.css')
		link(rel='shortcut icon' type='image/png' href='img/favicon.png')

	body
		h1= tour
		h1 The Park Camper
		p this is just some text
```

buffered code is code that adds things to the output

unbuffered code doesnt change the output

```javascript
doctype html
html
	head
		title Natours
		link(rel='stylesheet' href='css/style.css')
		link(rel='shortcut icon' type='image/png' href='img/favicon.png')

	body
		h1= tour
		h2= user.toUpperCase()
		// this comment is visible in html
		p this is just some text
		//- this one isnt

		- const x = 9;
		h2= 2*x
```

there's also interpolated code (ES6 Template Literals)

```pug
html
	head
		title Natours #{tour}
```

## Creating the base template

converting html into pug

```javascript
// html
<header class="header">
      <nav class="nav nav--tours">
        <a href="#" class="nav__el">All tours</a>
        <form class="nav__search">
          <button class="nav__search-btn">
            <svg>
              <use xlink:href="img/icons.svg#icon-search"></use>
            </svg>
          </button>
          <input
            type="text"
            placeholder="Search tours"
            class="nav__search-input"
          />
        </form>
      </nav>
      <div class="header__logo">
        <img src="img/logo-white.png" alt="Natours logo" />
      </div>
      <nav class="nav nav--user">
        <a href="#" class="nav__el">My bookings</a>
        <a href="#" class="nav__el">
          <img src="img/user.jpg" alt="User photo" class="nav__user-img" />
          <span>Jonas</span>
        </a>

        <!-- <button class="nav__el">Log in</button>
        <button class="nav__el nav__el--cta">Sign up</button> -->
      </nav>
    </header>

// pug
		// Header
		header.header
			nav.nav.nav--tours
				a.nav__el(href='#')
			.header__logo
				img(src='img/logo-white.png' alt='Natours logo')
			nav.nav.nav--user
				a.nav_el(href='#') My Bookings
				a.nav_el(href='#')
					img.nav__user-img(src='img/user.jpg' alt='User photo')
					span Jonas
				button.nav__el Log In
				button.nav__el.nav__el--cta Sign Up
```

## Including files into pug templates

you can include files in other pug files

```pug
doctype html
html(lang='en')
	head
		link(rel='stylesheet' href='css/style.css')
		link(rel='shortcut icon' type='image/png' href='img/favicon.png')
		link(rel='stylesheet' href='https://fonts.googleapis.com/css?family=Lato:300,300i,700')
		meta(charset='UTF-8')
		meta(name='viewport' content='width=device-width, initial-scale=1.0')
		title Natours | Exciting tours for adventurous people

	body
		// Header
		include _header

		// Content
		main.main
			h1= tour

		// Footer
		include _footer

```

## Extending the base template with blocks

Extends are the most powerful portion of pug

### Setting up routes

```javascript
app.get("/overview", (req, res) => {
  res.status(200).render("overview", {
    title: "All Tours",
  });
});

app.get("/tour", (req, res) => {
  res.status(200).render("tour", {
    title: "The Forest Hiker Tour",
  });
});
```

In smaller templates we write what we need and then extend the base with our new templates

base.pug

```pug
doctype html
html(lang='en')
	head
		link(rel='stylesheet' href='css/style.css')
		link(rel='shortcut icon' type='image/png' href='img/favicon.png')
		link(rel='stylesheet' href='https://fonts.googleapis.com/css?family=Lato:300,300i,700')
		meta(charset='UTF-8')
		meta(name='viewport' content='width=device-width, initial-scale=1.0')
		title Natours | Exciting tours for adventurous people

	body
		// Header
		include _header

		// Content
		block content
			h1 This is a placeholder heading

		// Footer
		include _footer

```

overview.pug

```pug
extends base

block content
	h1 This is the tour overview
```

each file can only extend one other file

## Setting up proper folder structure

viewroutes.js

```javascript
const express = require("express");

const router = express.Router();

router.get("/", (req, res) => {
  res.status(200).render("base", {
    tour: "The Forest Hiker",
    user: "eugene",
  });
});

router.get("/overview", (req, res) => {
  res.status(200).render("overview", {
    title: "All Tours",
  });
});

router.get("/tour", (req, res) => {
  res.status(200).render("tour", {
    title: "The Forest Hiker Tour",
  });
});

module.exports = router;
```

app.js

```javascript
// Mounting routers -- YES THIS IS ALSO MIDDLEWARE

app.use("/", viewRouter);
app.use("/api/v1/tours", tourRouter);
app.use("/api/v1/users", userRouter);
app.use("/api/v1/reviews", reviewRouter);
```

its a standard refactor pattern overall
