# Mongo Data Modeling

One of the hardest parts of development is correctly modeling data

Data modeling is the process of taking data from a real world scenario and turning it into a structured and logical data model

In an example of an online shop theres a lot of sets of data that need to be modeled

So we turn that jumble into a set of logical data sets and connections between the data

Data modeling is not always straightforward and there isnt always a right answer

- Identify types of relationships between data
- Understand referencing vs embedding
- Understand when to reference vs embed
- Understand types of referencing

## Types of relationships

- One to One
  - Movie can only have one name
- One to Many (1:FEW/1:MANY/1:LOADS)
  - Movie can win a few awards (1:10-100s)
  - Movie can have many reviews (1:1000-10000s)
  - Apps can have tons of log events (if something can expand indefinitely its a 1:LOADS)
- Many to Many
  - Many movies can have many various actors in them

## Referencing vs Embedding

Referencing is when you list the id of the object you want to reference in your document
Embedding is when the contained document is embedded in the parent document from the start

Normalized documents can be denormalized at will but not the other way around

If you have datasets that are inextricably linked, use embedding
If you have datasets that need to be referenced on their own, use referencing

## When to embed vs when to reference

|        Criterion        |                   Embedding                    |       Referencing        |
| :---------------------: | :--------------------------------------------: | :----------------------: |
|    Relationship type    |                  1:FEW/1:MANY                  | 1:MANY/1:LOADS/MANY:MANY |
| How often data is read  |             Read/Write ratio high              |   Read/Write ratio low   |
| How related is the data | Doesnt make sense to query the data separately |           Does           |

## Types of referencing

- Child referencing
  - Parent is aware of all of its children
  - Child doesnt know about its parent
  - Tightly couples parent and children
- Parent referencing
  - Parent doesnt know about all of its children
  - Child is aware of its parent
- Two-way referencing
  - Parent is aware of all of its children
  - Child is aware of all of its parents

Generally the more skewed the relationship the more parent referencing makes sense

BSON documents are limited to 16MB so minimizing the amount of data resulting from a query is a good idea

Never allow an array in a document to grow indefinitely

## Summary

- Structure the data to match the ways that your applicaiton will query and update data. In other words, identify the questions that arise from your application's use cases and then model your data so that the questions get answered in the most efficient way
- Generally, favor embedding unless there is a good reason not to embed
- 1:TON or MANY:MANY is a good reason to reference or when the data is updated a lot or needs to be accessed on its own
- Use embedding when data is read a lot but not updated a lot, or when two datasets belong together intrinsically
- Dont allow an array to grow indefinitely
- Use two-way referencing in many:many relationships

# Code notes

Creating embedded documents (using arrays)

```javascript
    startLocation: {
      // GeoJSON
      type: {
        type: String,
        default: 'Point',
        enum: ['Point'],
      },
      coordinates: [Number],
      address: String,
      desscription: String,
    },
    locations: [
      {
        type: {
          type: String,
          default: 'Point',
          enum: ['Point'],
        },
        coordinates: [Number],
        address: String,
        description: String,
        day: Number,
      },
    ],
```

Embedding user documents into tour documents

```javascript
// /* ---------- Populate the guides and embed them into the document ------- */
tourSchema.pre("save", async function (next) {
  const guidesPromises = this.guides.map((guideId) => User.findById(guideId));
  this.guides = await Promise.all(guidesPromises);
  next();
});
```

Setting up references in a model

```javascript
    guides: [
      {
        type: mongoose.Schema.ObjectId,
        ref: 'User',
      },
    ],
```

Populating the data

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
  const tour = await Tour.findById(request.params.id).populate({
    path: "guides",
    select: "-__v -passwordChangedAt",
  });

  if (!tour) {
    return next(new AppError("Requested tour does not exist", 404));
  }

  response.json({
    status: "success",
    params: request.params,
    data: {
      tour,
    },
  });
});
```

Since we'd like to populate this data everywhere, we will extract it to a query middleware

```javascript
tourSchema.pre(/^find/, function (next) {
  this.populate({
    path: "guides",
    select: "-__v -passwordChangedAt",
  });
  next();
});
```

Populating referenced data is extremely powerful

## Creating the review model

```javascript
const mongoose = require("mongoose");

const reviewSchema = new mongoose.Schema(
  {
    review: {
      type: String,
      required: [true, "Review cannot be empty"],
    },
    rating: {
      type: Number,
      min: 1,
      max: 5,
    },
    createdAt: {
      type: Date,
      default: Date.now(),
    },
    tour: {
      type: mongoose.Schema.ObjectId,
      ref: "Tour",
      required: [true, "Review must belong to a tour"],
    },
    user: {
      type: mongoose.Schema.ObjectId,
      ref: "User",
      required: [true, "Review must belong to a user"],
    },
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

const Review = mongoose.model("Review", reviewSchema);

module.exports = Review;
```

### reviewController.js

```javascript
const Review = require("../models/reviewModel");
const catchAsync = require("../utils/catchAsync");

/* ---------------------------- Create new review --------------------------- */
exports.createReview = catchAsync(async (request, response, next) => {
  const newReview = await Review.create(request.body);

  response.status(201).json({
    status: "success",
    data: {
      review: newReview,
    },
  });
});

/* ----------------------------- Get all reviews ---------------------------- */
exports.getAllReviews = catchAsync(async (request, response, next) => {
  const allReviews = await Review.find();

  response.json({
    status: "success",
    reviews: allReviews,
  });
});
```

### reviewRoutes.js

```javascript
const express = require("express");
const authController = require("../controllers/authController");
const reviewController = require("../controllers/reviewController");

const router = express.Router();

router
  .route("/")
  .get(reviewController.getAllReviews)
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );

module.exports = router;
```

## Populating user and tour data onto the reviews

```javascript
reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "tour",
  });
  next();
});

reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "user",
  });
  next();
});
```

You can also chain populates inside of one middleware function

## Virtual populate

Virtual populate is a somewhat advanced feature in mongo

We've engineered parent referencing on the reviews to the tours, so how can we go about it in the other direction?

- We could query for reviews when we query for tours or child reference on each tour document
- We can also use Virtual Populate

With VP we can populate the tours with reviews without keeping an array of id's on the tour

```javascript
tourSchema.virtual("reviews", {
  ref: "Review", // identifying the model to reference
  foreignField: "tour", // the foreign reference where to go looking
  localField: "_id", // what to go looking for in the other model
});
```

Its important to avoid cascading population however

```javascript
// reviewSchema.pre(/^find/, function (next) {
//   this.populate({
//     path: 'tour',
//     select: 'name',
//   });
//   next();
// });

// reviewSchema.pre(/^find/, function (next) {
//   this.populate({
//     path: 'user',
//   });
//   next();
// });

reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "user",
    select: "name photo",
  });
  next();
});
```

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
  const tour = await Tour.findById(request.params.id).populate("reviews");

  if (!tour) {
    return next(new AppError("Requested tour does not exist", 404));
  }

  response.json({
    status: "success",
    params: request.params,
    data: {
      tour,
    },
  });
});
```

---

# Simple Nested Routes

Consider the practical aspect of how you want to create a review

It is impractical to hand feed object id's in production

The user id should come from the currently logged in user, and the tour id should come from the current tour

When submitting a review you want to submit a review like this

`POST /tour/234trega/reviews`

This above is a parent route, which makes a lot of sense in the context of clearly defined parent child relationships

The url should write to the reviews resource on the post resource

`GET /tour/234trega/reviews`

Get us all the reviews from the tour

`GET /tour/234trega/reviews/546ojrgkalr`

Get a specific review on the tour

```javascript
// in tourRoutes.js
router
  .route("/:tourId/reviews")
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );
```

```javascript
// in reviewController.js
exports.createReview = catchAsync(async (request, response, next) => {
  // Allow nested routes by defining these args when they're not there
  if (!request.body.tour) request.body.tour = request.params.tourId;
  if (!request.body.user) request.body.user = request.user.id; // the user object comes from protect
  const newReview = await Review.create(request.body);

  response.status(201).json({
    status: "success",
    data: {
      review: newReview,
    },
  });
});
```

# Nesting routes with Express

Express has an advanced feature to nest routes

The problem with the above implementation is that it is messy, because a review route is now in the tour router and we're doubling up on routes

We can use mergeparams and using routers inside routers

By default each router only has access to the parameters of its own specific route

So to allow sharing of params set mergeParams to true

```javascript
const express = require("express");
const tourController = require("../controllers/tourController");
const authController = require("../controllers/authController");
const reviewRouter = require("./reviewRoutes");

const router = express.Router();

// if you ever see a url like this, hand it off to the reviewRouter
router.use("/:tourId/reviews", reviewRouter);

router
  .route("/top-5-cheap")
  .get(tourController.aliasTopTours, tourController.getAllTours);

router.route("/tour-stats").get(tourController.getTourStats);

router.route("/monthly-plan/:year").get(tourController.getMonthlyPlan);

router
  .route("/")
  .get(authController.protect, tourController.getAllTours)
  .post(tourController.createTour);
router
  .route("/:id")
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(
    authController.protect,
    authController.restrictTo("admin", "lead-guide"),
    tourController.deleteTour
  );

module.exports = router;
```

```javascript
const express = require("express");
const authController = require("../controllers/authController");
const reviewController = require("../controllers/reviewController");

const router = express.Router({ mergeParams: true });

router
  .route("/")
  .get(reviewController.getAllReviews)
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );

module.exports = router;
```

## Nested GET Endpoint

```javascript
exports.getAllReviews = catchAsync(async (request, response, next) => {
  // if a tourId param exists, set the filter to respond with just the reviews
  // of that tour
  let filter = {};
  if (request.params.tourId) filter = { tour: request.params.tourId };

  const allReviews = await Review.find(filter);

  response.json({
    status: "success",
    reviews: allReviews,
  });
});
```

# Factory functions

Factory functions are functions that return functions, in our case to perform CRUDL ops

## DELETE

`In handlerFactory.js`

```javascript
const catchAsync = require("../utils/catchAsync");
const AppError = require("../utils/appError");

exports.deleteOne = (Model) =>
  catchAsync(async (request, response, next) => {
    const doc = await Model.findByIdAndDelete(request.params.id);

    if (!doc) {
      return next(new AppError("No document found with id", 404));
    }

    response.status(204).json({
      status: "success",
      data: null,
    });
  });
```

The idea is to generalize our functions to avoid repeating code, since the operations are fundamentally similar across all controllers

`In tourController.js`

```javascript
exports.deleteTour = factory.deleteOne(Tour);
// exports.deleteTour = catchAsync(async (request, response, next) => {
//   const tour = await Tour.findByIdAndDelete(request.params.id);

//   if (!tour) {
//     return next(new AppError('Requested tour does not exist', 404));
//   }

//   response.status(204).json({
//     status: 'success',
//     data: null,
//   });
// });
```

did this in the other controllers too

## CREATE/UPDATE

```javascript
exports.updateOne = (Model) =>
  catchAsync(async (request, response, next) => {
    const doc = await Model.findByIdAndUpdate(request.params.id, request.body, {
      new: true,
      runValidators: true,
    });

    if (!doc) {
      return next(new AppError("No document found with that id", 404));
    }

    response.status(200).json({
      status: "success",
      data: { doc },
    });
  });
```

not all controller functions can be extracted to the factory, but the basic repetitive ones can be~

extracting setting the tour and user id's to a middleware

```javascript
exports.setTourUserIds = (request, response, next) => {
  // Allow nested routes by defining these args when they're not there
  if (!request.body.tour) request.body.tour = request.params.tourId;
  if (!request.body.user) request.body.user = request.user.id; // the user object comes from protect
  next();
};

// don't forget to call the middleware in the route

exports.createReview = factory.createOne(Review);
```

## Using middleware to maximize utility of factory functions

```javascript
/* ----------------------- VIEW OWN INFO (MIDDLEWARE) ----------------------- */
exports.getMe = (request, response, next) => {
  request.params.id = request.user.id;
  next();
};
```

```javascript
router.get(
  "/me",
  authController.protect,
  userController.getMe,
  userController.getUser
);
```

## Fixing auth on resources

Tours are the core product that we serve to the public so it does not make sense to make the tours api protected if we want other websites to display our tours. Also only admins and lead guides should have rights to editing tours so we will restrict it to them

```javascript
const express = require("express");
const userController = require("../controllers/userController");
const authController = require("../controllers/authController");

const router = express.Router();

router.post("/signup", authController.signUp);
router.post("/login", authController.login);
router.post("/forgot-password", authController.forgotPassword);
router.patch("/reset-password/:token", authController.resetPassword);

// ⬇️ All middleware after this call is blanket protected
router.use(authController.protect);

router.get("/me", userController.getMe, userController.getUser);
router.patch("/update-data", userController.updateMe);
router.patch("/update-password", authController.updatePassword);
router.delete("/delete-me", userController.deleteMe);

router.use(authController.restrictTo("admin"));

router
  .route("/")
  .get(userController.getAllUsers)
  .post(userController.createUser);

router
  .route("/:id")
  .get(userController.getUser)
  .patch(userController.updateUser)
  .delete(userController.deleteUser);

module.exports = router;
```

## Optimizing read performance in mongoDB

Read performance is really important in mongodb

In large scale datasets it is important to use indexes because in a find operation all documents are evaluated

Indexing allows us to extract ordered indices with pared down data to find data much more efficiently

```javascript
tourSchema.index({
  // 1 is sort ascending, -1 is sort descending
  price: 1,
});
```

Indexes may or may not be unique, requiring a field be unique in the model will trigger indexing automatically

If we query data together frequently compound indexes make sense as well

```javascript
tourSchema.index({
  // 1 is sort ascending, -1 is sort descending
  price: 1,
  ratingsAverage: 1,
});
```

You need to study the access patterns of what data is accessed the most and set your indexes appropriately

You don't want to blindly index everything and just hope for the best, because at the end of the day indexes consume storage resources and computational resources (indexes need to be refreshed anytime a document in a collection is updated)

```javascript
tourSchema.index({
  slug: 1,
});
```

## Calculating statistics on tour

Summarizing a related data set on the main data set is common. It makes sense to store the average rating and amount of ratings on the tours instead of querying reviews multiple times over for each tour

We will use a static method on the schema, instead of an instance method

In static methods the this keyword points to the model

In reviewModel.js

```javascript
reviewSchema.pre("save", function (next) {
  // You cannot call the static method by using Review.blahblah
  // So use this.constructor

  this.constructor.calcAverageRatings(this.tour);
  next();
});

reviewSchema.statics.calcAverageRatings = async function (tourID) {
  const stats = await this.aggregate([
    {
      $match: { tourID },
    },
    {
      $group: {
        _id: "$tour",
        nRatings: { $sum: 1 },
        avgReview: { $avg: "$rating" },
      },
    },
  ]);
  console.log(stats);
};
```

Jonas made a booboo above, you're supposed to use post, not pre

```javascript
reviewSchema.post("save", function () {
  // You cannot call the static method by using Review.blahblah
  // So use this.constructor

  this.constructor.calcAverageRatings(this.tour);
});

reviewSchema.statics.calcAverageRatings = async function (tourID) {
  const stats = await this.aggregate([
    {
      $match: { tour: tourID },
    },
    {
      $group: {
        _id: "$tour",
        nRatings: { $sum: 1 },
        avgReview: { $avg: "$rating" },
      },
    },
  ]);
  console.log(stats);

  await Tour.findByIdAndUpdate(tourID, {
    ratingsQuantity: stats[0].nRating,
    ratingsAverage: stats[0].avgRating,
  });
};
```

This above is all well and good if users are posting new reviews but we also need to be able to handle users modifying their reviews or deleting

## Calculating statistics after deletes, edits, etc

for commands like findByIdAndUpdate and Delete we do not have document middleware, just query middleware.

simply put we dont have access to the document

but there's a way around this

```javascript
reviewSchema.pre(/^findOneAnd/, async function (next) {
  // in this context the this keyword is the query not the document
  // so we just run findOne
  this.r = await this.findOne();
  console.log(this.r);
  next();
  // We need to ensure we are using relevant data to calculate ratings
  // You cant change this to a post function because we lose access to the query
});

reviewSchema.post(/^findOneAnd/, async function () {
  // In order to maintain state we assign the result of the query to this
  // also in this case the method is nested even deeper
  await this.r.constructor.calcAverageRatings(this.r.tour);
});
```
