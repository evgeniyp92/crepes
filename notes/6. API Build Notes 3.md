# Mongo Data Modeling

One of the hardest parts of development is correctly modeling data

Data modeling is the process of taking data from a real world scenario and turning it into a structured and logical data model

In an example of an online shop theres a lot of sets of data that need to be modeled

So we turn that jumble into a set of logical data sets and connections between the data

Data modeling is not always straightforward and there isnt always a right answer

- Identify types of relationships between data
- Understand referencing vs embedding
- Understand when to reference vs embed
- Understand types of referencing

## Types of relationships

- One to One
  - Movie can only have one name
- One to Many (1:FEW/1:MANY/1:LOADS)
  - Movie can win a few awards (1:10-100s)
  - Movie can have many reviews (1:1000-10000s)
  - Apps can have tons of log events (if something can expand indefinitely its a 1:LOADS)
- Many to Many
  - Many movies can have many various actors in them

## Referencing vs Embedding

Referencing is when you list the id of the object you want to reference in your document
Embedding is when the contained document is embedded in the parent document from the start

Normalized documents can be denormalized at will but not the other way around

If you have datasets that are inextricably linked, use embedding
If you have datasets that need to be referenced on their own, use referencing

## When to embed vs when to reference

|        Criterion        |                   Embedding                    |       Referencing        |
| :---------------------: | :--------------------------------------------: | :----------------------: |
|    Relationship type    |                  1:FEW/1:MANY                  | 1:MANY/1:LOADS/MANY:MANY |
| How often data is read  |             Read/Write ratio high              |   Read/Write ratio low   |
| How related is the data | Doesnt make sense to query the data separately |           Does           |

## Types of referencing

- Child referencing
  - Parent is aware of all of its children
  - Child doesnt know about its parent
  - Tightly couples parent and children
- Parent referencing
  - Parent doesnt know about all of its children
  - Child is aware of its parent
- Two-way referencing
  - Parent is aware of all of its children
  - Child is aware of all of its parents

Generally the more skewed the relationship the more parent referencing makes sense

BSON documents are limited to 16MB so minimizing the amount of data resulting from a query is a good idea

Never allow an array in a document to grow indefinitely

## Summary

- Structure the data to match the ways that your applicaiton will query and update data. In other words, identify the questions that arise from your application's use cases and then model your data so that the questions get answered in the most efficient way
- Generally, favor embedding unless there is a good reason not to embed
- 1:TON or MANY:MANY is a good reason to reference or when the data is updated a lot or needs to be accessed on its own
- Use embedding when data is read a lot but not updated a lot, or when two datasets belong together intrinsically
- Dont allow an array to grow indefinitely
- Use two-way referencing in many:many relationships

# Code notes

Creating embedded documents (using arrays)

```javascript
    startLocation: {
      // GeoJSON
      type: {
        type: String,
        default: 'Point',
        enum: ['Point'],
      },
      coordinates: [Number],
      address: String,
      desscription: String,
    },
    locations: [
      {
        type: {
          type: String,
          default: 'Point',
          enum: ['Point'],
        },
        coordinates: [Number],
        address: String,
        description: String,
        day: Number,
      },
    ],
```

Embedding user documents into tour documents

```javascript
// /* ---------- Populate the guides and embed them into the document ------- */
tourSchema.pre("save", async function (next) {
  const guidesPromises = this.guides.map((guideId) => User.findById(guideId));
  this.guides = await Promise.all(guidesPromises);
  next();
});
```

Setting up references in a model

```javascript
    guides: [
      {
        type: mongoose.Schema.ObjectId,
        ref: 'User',
      },
    ],
```

Populating the data

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
  const tour = await Tour.findById(request.params.id).populate({
    path: "guides",
    select: "-__v -passwordChangedAt",
  });

  if (!tour) {
    return next(new AppError("Requested tour does not exist", 404));
  }

  response.json({
    status: "success",
    params: request.params,
    data: {
      tour,
    },
  });
});
```

Since we'd like to populate this data everywhere, we will extract it to a query middleware

```javascript
tourSchema.pre(/^find/, function (next) {
  this.populate({
    path: "guides",
    select: "-__v -passwordChangedAt",
  });
  next();
});
```

Populating referenced data is extremely powerful

## Creating the review model

```javascript
const mongoose = require("mongoose");

const reviewSchema = new mongoose.Schema(
  {
    review: {
      type: String,
      required: [true, "Review cannot be empty"],
    },
    rating: {
      type: Number,
      min: 1,
      max: 5,
    },
    createdAt: {
      type: Date,
      default: Date.now(),
    },
    tour: {
      type: mongoose.Schema.ObjectId,
      ref: "Tour",
      required: [true, "Review must belong to a tour"],
    },
    user: {
      type: mongoose.Schema.ObjectId,
      ref: "User",
      required: [true, "Review must belong to a user"],
    },
  },
  {
    toJSON: { virtuals: true },
    toObject: { virtuals: true },
  }
);

const Review = mongoose.model("Review", reviewSchema);

module.exports = Review;
```

### reviewController.js

```javascript
const Review = require("../models/reviewModel");
const catchAsync = require("../utils/catchAsync");

/* ---------------------------- Create new review --------------------------- */
exports.createReview = catchAsync(async (request, response, next) => {
  const newReview = await Review.create(request.body);

  response.status(201).json({
    status: "success",
    data: {
      review: newReview,
    },
  });
});

/* ----------------------------- Get all reviews ---------------------------- */
exports.getAllReviews = catchAsync(async (request, response, next) => {
  const allReviews = await Review.find();

  response.json({
    status: "success",
    reviews: allReviews,
  });
});
```

### reviewRoutes.js

```javascript
const express = require("express");
const authController = require("../controllers/authController");
const reviewController = require("../controllers/reviewController");

const router = express.Router();

router
  .route("/")
  .get(reviewController.getAllReviews)
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );

module.exports = router;
```

## Populating user and tour data onto the reviews

```javascript
reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "tour",
  });
  next();
});

reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "user",
  });
  next();
});
```

You can also chain populates inside of one middleware function

## Virtual populate

Virtual populate is a somewhat advanced feature in mongo

We've engineered parent referencing on the reviews to the tours, so how can we go about it in the other direction?

- We could query for reviews when we query for tours or child reference on each tour document
- We can also use Virtual Populate

With VP we can populate the tours with reviews without keeping an array of id's on the tour

```javascript
tourSchema.virtual("reviews", {
  ref: "Review", // identifying the model to reference
  foreignField: "tour", // the foreign reference where to go looking
  localField: "_id", // what to go looking for in the other model
});
```

Its important to avoid cascading population however

```javascript
// reviewSchema.pre(/^find/, function (next) {
//   this.populate({
//     path: 'tour',
//     select: 'name',
//   });
//   next();
// });

// reviewSchema.pre(/^find/, function (next) {
//   this.populate({
//     path: 'user',
//   });
//   next();
// });

reviewSchema.pre(/^find/, function (next) {
  this.populate({
    path: "user",
    select: "name photo",
  });
  next();
});
```

```javascript
exports.getTour = catchAsync(async (request, response, next) => {
  const tour = await Tour.findById(request.params.id).populate("reviews");

  if (!tour) {
    return next(new AppError("Requested tour does not exist", 404));
  }

  response.json({
    status: "success",
    params: request.params,
    data: {
      tour,
    },
  });
});
```

---

# Simple Nested Routes

Consider the practical aspect of how you want to create a review

It is impractical to hand feed object id's in production

The user id should come from the currently logged in user, and the tour id should come from the current tour

When submitting a review you want to submit a review like this

`POST /tour/234trega/reviews`

This above is a parent route, which makes a lot of sense in the context of clearly defined parent child relationships

The url should write to the reviews resource on the post resource

`GET /tour/234trega/reviews`

Get us all the reviews from the tour

`GET /tour/234trega/reviews/546ojrgkalr`

Get a specific review on the tour

```javascript
// in tourRoutes.js
router
  .route("/:tourId/reviews")
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );
```

```javascript
// in reviewController.js
exports.createReview = catchAsync(async (request, response, next) => {
  // Allow nested routes by defining these args when they're not there
  if (!request.body.tour) request.body.tour = request.params.tourId;
  if (!request.body.user) request.body.user = request.user.id; // the user object comes from protect
  const newReview = await Review.create(request.body);

  response.status(201).json({
    status: "success",
    data: {
      review: newReview,
    },
  });
});
```

# Nesting routes with Express

Express has an advanced feature to nest routes

The problem with the above implementation is that it is messy, because a review route is now in the tour router and we're doubling up on routes

We can use mergeparams and using routers inside routers

By default each router only has access to the parameters of its own specific route

So to allow sharing of params set mergeParams to true

```javascript
const express = require("express");
const tourController = require("../controllers/tourController");
const authController = require("../controllers/authController");
const reviewRouter = require("./reviewRoutes");

const router = express.Router();

// if you ever see a url like this, hand it off to the reviewRouter
router.use("/:tourId/reviews", reviewRouter);

router
  .route("/top-5-cheap")
  .get(tourController.aliasTopTours, tourController.getAllTours);

router.route("/tour-stats").get(tourController.getTourStats);

router.route("/monthly-plan/:year").get(tourController.getMonthlyPlan);

router
  .route("/")
  .get(authController.protect, tourController.getAllTours)
  .post(tourController.createTour);
router
  .route("/:id")
  .get(tourController.getTour)
  .patch(tourController.updateTour)
  .delete(
    authController.protect,
    authController.restrictTo("admin", "lead-guide"),
    tourController.deleteTour
  );

module.exports = router;
```

```javascript
const express = require("express");
const authController = require("../controllers/authController");
const reviewController = require("../controllers/reviewController");

const router = express.Router({ mergeParams: true });

router
  .route("/")
  .get(reviewController.getAllReviews)
  .post(
    authController.protect,
    authController.restrictTo("user"),
    reviewController.createReview
  );

module.exports = router;
```

## Nested GET Endpoint

```javascript
exports.getAllReviews = catchAsync(async (request, response, next) => {
  // if a tourId param exists, set the filter to respond with just the reviews
  // of that tour
  let filter = {};
  if (request.params.tourId) filter = { tour: request.params.tourId };

  const allReviews = await Review.find(filter);

  response.json({
    status: "success",
    reviews: allReviews,
  });
});
```

# Factory functions

Factory functions are functions that return functions, in our case to perform CRUDL ops

`In handlerFactory.js`

```javascript
const catchAsync = require("../utils/catchAsync");
const AppError = require("../utils/appError");

exports.deleteOne = (Model) =>
  catchAsync(async (request, response, next) => {
    const doc = await Model.findByIdAndDelete(request.params.id);

    if (!doc) {
      return next(new AppError("No document found with id", 404));
    }

    response.status(204).json({
      status: "success",
      data: null,
    });
  });
```

The idea is to generalize our functions to avoid repeating code, since the operations are fundamentally similar across all controllers

`In tourController.js`

```javascript
exports.deleteTour = factory.deleteOne(Tour);
// exports.deleteTour = catchAsync(async (request, response, next) => {
//   const tour = await Tour.findByIdAndDelete(request.params.id);

//   if (!tour) {
//     return next(new AppError('Requested tour does not exist', 404));
//   }

//   response.status(204).json({
//     status: 'success',
//     data: null,
//   });
// });
```
